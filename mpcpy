#!/usr/bin/env python2.6

# TODO: output control
# FIXME: move idle logic all into mpd

import curses
import socket
import sys, errno, os
import re
import time
import string
import select

debug_plchanges = False

from BufRead import BufRead

def ctrl_and(n):
	return chr(ord(n) - ord('a') + 1)

def default_set(map, key, val):
	if key not in map.keys():
		map[key] = val

KEY_DEFINITIONS = {
	'q': lambda self: self.exit(),
	'j': lambda self: self.view_set(self.draw_selected + 1),
	'k': lambda self: self.view_set(self.draw_selected - 1),
	ctrl_and('d'): lambda self: self.view_set(self.draw_selected + self.screen.get_max_y() / 2),
	ctrl_and('u'): lambda self: self.view_set(self.draw_selected - self.screen.get_max_y() / 2),
	ctrl_and('f'): lambda self: self.view_set(self.draw_selected + self.screen.get_max_y()),
	ctrl_and('b'): lambda self: self.view_set(self.draw_selected - self.screen.get_max_y()),
	ctrl_and('e'): lambda self: self.view_scroll(+1),
	ctrl_and('y'): lambda self: self.view_scroll(-1),

	'!': lambda self: self.shellout(),

	'gg': lambda self: self.view_set(0),
	'gs': lambda self: self.seek(),
	'gS': lambda self: self.playlist_save(),
	'gL': lambda self: self.playlist_load(),
	'gC': lambda self: self.playlist_clear(),

	'"': lambda self: self.goto_mark(),

	'm': lambda self: self.create_mark(),

	'i': lambda self: self.info(self.mpd.playlist[self.draw_selected]),

	'G': lambda self: self.view_set(len(self.mpd.playlist) - 1),

	'H': lambda self: self.screen_position(-1),
	'L': lambda self: self.screen_position(0),
	'M': lambda self: self.screen_position(+1),

	'd':  lambda self: self.playlist_remove_current(),
	'p':  lambda self: self.mpd.toggle(),
	's':  lambda self: self.mpd.stop(),
	'\n': lambda self: self.mpd.play(self.draw_selected),

	'Q': lambda self: self.queue(),

	'>': lambda self: self.mpd.next(),
	'<': lambda self: self.mpd.prev(),

	'r': lambda self: self.mpd.repeat(),
	'z': lambda self: self.mpd.random(),
	'y': lambda self: self.mpd.single(),
	'c': lambda self: self.mpd.consume(),
	'x': lambda self: self.mpd.crossfade(),

	'X': lambda self: self.set_xfade(),

	'W': lambda self: self.shift_tracks('up'),
	'w': lambda self: self.shift_tracks('down'),

	' ': lambda self: self.toggle_selection(),

	'/': lambda self: self.search('forwards'),
	'?': lambda self: self.search('backwards'),
	'n': lambda self: self.search('next'),
	'N': lambda self: self.search('prev'),

	'o': lambda self: self.view_current(),

	'P': lambda self: self.password(),

	'u': lambda self: self.mpd.update(),

	# 12 = "\f" = ctrl+L
	chr(12): lambda self: self.refresh(),

	'{': lambda self: self.view_move_paragraph(-1),
	'}': lambda self: self.view_move_paragraph(+1),
}

# const
STATUS_HEIGHT  = 2
SCROLL_OFF     = 10
CURSES_TIMEOUT = 250

# relative differences
SPACE_TIME     = 2
SPACE_ARTIST   = 5
SPACE_TITLE    = 8
SPACE_ALBUM    = 4

def list_to_map(lst):
	curmap = {}
	i = 0
	while i < len(lst):
		pos = lst[i].find(':')
		if pos == -1:
			raise Exception("list_to_map: no colon in line: \"%s\"" % lst[i])

		curmap[lst[i][:pos]] = lst[i][pos+2:]
		i += 1
	return curmap

def try_key(dict, key, default = ''):
	return dict[key] if key in dict.keys() else default

def hoststr(host, port):
	return "%s:%s" % (host, port)

def parse_playlist(raw):
	def filter_val(key, val):
		if key == 'Pos':
			return int(val)
		return val

	playlist = []
	curmap = {}
	for line in raw:
		colon = line.find(':')
		if colon == -1:
			raise MPDException("playlist: no colon in line: \"%s\"" % line)

		key = line[:colon]
		val = filter_val(key, line[colon+2:])

		if key in curmap:
			playlist.append(curmap)
			curmap = {}

		curmap[key] = val

	if len(playlist) and curmap != playlist[-1]:
		playlist.append(curmap)

	return playlist

def format_time(s):
	n = int(s)
	secs = n % 60
	mins = n / 60
	hr = mins / 60
	mins %= 60

	if hr:
		return "%02d:%02d:%02d" % (hr, mins, secs)
	return "%02d:%02d" % (mins, secs)

def statusstr(statusdict):
	return "[%s%s%s%s%s]" % (
			'r' if statusdict['repeat' ] > 0 else '-',
			'z' if statusdict['random' ] > 0 else '-',
			'y' if statusdict['single' ] > 0 else '-',
			'x' if statusdict['xfade'  ] > 0 else '-',
			'c' if statusdict['consume'] > 0 else '-')

def autocomplete_do(all, str):
	min_len = 999
	str_len = len(str)
	chosen = []

	for i in all:
		if i[:str_len] == str:
			chosen.append(i)

	if len(chosen) == 1:
		return chosen[0]

	i = str_len
	try:
		lengthening = True
		while lengthening:
			ch = chosen[0][i + 1]

			for j in chosen:
				if j[i + 1] != ch:
					lengthening = False
					break

			if lengthening:
				i += 1
	except:
		pass # hit the end of one

	try:
		return chosen[0][:i]
	except:
		return str

# ----------------------------------------------------
# socket/mpd code

class MpcpyException(Exception):
	pass
class MPDException(Exception):
	pass

def create_mpd(screen):
	host = os.getenv('MPD_HOST', 'localhost')
	port = os.getenv('MPD_PORT', '6600')
	if host.find("@") != -1:
		parts = host.split("@", 1)
		pw = parts[0]
		host = parts[1]
	else:
		pw = ''

	try:
		port = int(port)
	except ValueError as e:
		raise MPDException("Couldn't parse port (%s): %s" % (port, e))


	sock = socket.socket()
	try:
		sock.connect((host, port))
	except Exception as e:
		raise MPDException("Couldn't connect to mpd @ %s - %s" % (hoststr(host, port), e))

	bufsock = BufRead(sock)

	firstline = bufsock.readLine()
	version_data = firstline.split()

	if len(version_data) != 3 or version_data[0] != 'OK' or version_data[1] != 'MPD':
		raise MPDException("Invalid string from mpd: %s" % firstline)

	vers = version_data[2].split('.')
	if len(vers) != 3:
		raise MPDException("Invalid version string from mpd: %s" % version_data[2])

	try:
		valid_version = int(vers[0]) == 0 and (16 <= int(vers[1]) and int(vers[1]) <= 21)

		if not valid_version and not screen.confirm("MPD (%s) version: %s, continue? (Y/n) " % (hoststr(host, port), version_data[2])):
			raise MPDException("Invalid MPD version: %s" % version_data[2])
	except TypeError as e:
		raise MPDException("Invalid version string from mpd: %s" % version_data[2])

	return Mpd(host, port, pw, bufsock)


class Mpd:
	def __init__(self, host, port, pw, bufsock):
		self.host = host
		self.port = port
		self.bufsock = bufsock
		self.playlist = []
		self.current = {}
		self.statusdict = {}
		self.xfade = 5
		self.waiting_on_cmd = ''
		self.is_idle = False
		if len(pw):
			self.attempt_password(pw)
		self.update_current()
		self.update_statusdict()
		self.update_playlist_full()

	def hoststr(self):
		return hoststr(self.host, self.port)


	def close(self):
		self.bufsock.close()

	def cmd_raw(self, cmd):
		if self.waiting_on_cmd:
			raise MpcpyException("still waiting on a previous command (\"{0}\")".format(self.waiting_on_cmd))
		self.unidle()
		self.bufsock.send(cmd + '\n')

	def readlines(self, prevcmd):
		lines = []

		while True:
			got = self.bufsock.readLine()

			if len(got) == 0:
				raise MPDException("mpd connection closed")

			if got == 'OK':
				return lines
			elif got[:3] == 'ACK':
				if prevcmd.find('password') == 0:
					extra = ''
				else:
					extra = ' (from "%s")' % prevcmd
				raise MPDException("MPD error: %s%s" % (got, extra))

			lines.append(got)

	def idle_response(self):
		self.is_idle = False
		return self.readlines('<unidling>')

	def current_pos(self):
		return try_key(self.current, 'Pos') if self.current else -1

	def cmd(self, cmd):
		"""Send 'cmd' to mpd, and read lines until we get an 'OK'"""
		self.cmd_raw(cmd)
		return self.readlines(cmd)

	def cmd_noreply(self, cmd, **kwargs):
		if 'nowait' in kwargs and kwargs['nowait']:
			self.cmd_raw(cmd)
			self.waiting_on_cmd = cmd
		else:
			ret = self.cmd(cmd)
			self.check_noreply(ret)

	def check_noreply(self, lines):
		if len(lines) != 0:
			raise MPDException("Invalid MPD reply: %s" % lines[0])

	def resolve_wait(self):
		cmd = self.waiting_on_cmd
		self.waiting_on_cmd = ''
		lines = self.readlines(cmd)
		self.check_noreply(lines)

	def update_statusdict(self):
		statusdict = list_to_map(self.cmd("status"))

		default_set(statusdict, 'status', 'stop')
		default_set(statusdict, 'playlist', -1)
		default_set(statusdict, 'playlistlength', -1)
		default_set(statusdict, 'state', 'stop')
		default_set(statusdict, 'time', '00:00')

		for k in ['random', 'repeat', 'consume', 'xfade', 'single', 'volume', 'playlistlength']:
			try:
				statusdict[k] = int(statusdict[k])
			except:
				statusdict[k] = 0

		self.statusdict = statusdict

	def update_current(self):
		self.current = list_to_map(self.cmd("currentsong"))

	def update_playlist_full(self):
		self.playlist = parse_playlist(self.cmd("playlistinfo"))
		self.last_diffed_playlist = self.statusdict['playlist']

	def update_playlist_diff(self):
		playlist_changes = self.cmd('plchanges %s' % self.last_diffed_playlist)
		self.update_statusdict() # for status.playlistlength
		self.last_diffed_playlist = self.statusdict['playlist']

		old_length = len(self.playlist)
		new_length = int(self.statusdict['playlistlength'])

		changed_tracks = parse_playlist(playlist_changes)

		if debug_plchanges:
			print >>sys.stderr, "old_length = {0}".format(old_length)
			print >>sys.stderr, "new_length = {0}".format(new_length)
			print >>sys.stderr, "orig playlist:"
			for track in self.playlist:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])
			print >>sys.stderr, "changed_tracks:"

		for track in changed_tracks:
			if debug_plchanges:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])

			pos = track['Pos']
			if pos < old_length:
				if track['Id'] != self.playlist[pos]['Id']:
					self.playlist[pos] = track
			else:
				self.playlist.append(track)

		if new_length == 0:
			self.playlist = []
		else:
			self.playlist = self.playlist[:new_length]

		self.playlist = sorted(self.playlist, key=lambda track: track['Pos'])

		if debug_plchanges:
			print >>sys.stderr, "new playlist:"
			for track in self.playlist:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])

	def play(self, i = -1):
		if i != -1:
			self.cmd_noreply("play %d" % i, nowait=True)
		else:
			self.cmd_noreply("play", nowait=True)

	def pause(self):      self.cmd_noreply("pause")
	def stop(self):       self.cmd_noreply("stop")
	def prev(self):       self.cmd_noreply("previous")
	def next(self):       self.cmd_noreply("next")
	def stop(self):       self.cmd_noreply("stop")

	def seek(self, pos):
		idx = self.current_pos()
		if idx >= 0:
			self.cmd_noreply("seek %d %d" % (idx, pos))

	def toggle(self): self.stop() if self.statusdict['state'] == 'play' else self.play()
	def remove(self, n): self.cmd_noreply("delete %d" % n)

	def random(self):  self.cmd_noreply("random %d"  % (1 - self.statusdict['random']))
	def repeat(self):  self.cmd_noreply("repeat %d"  % (1 - self.statusdict['repeat']))
	def consume(self): self.cmd_noreply("consume %d" % (1 - self.statusdict['consume']))
	def single(self):  self.cmd_noreply("single %d"  % (1 - self.statusdict['single']))
	def attempt_password(self, pw): self.cmd_noreply('password "%s"' % pw)
	def move(self, a, b): self.cmd_noreply('move "%s" "%s"' % (a, b))

	def idle(self, on):
		if on:
			if not self.is_idle:
				self.cmd_raw('idle')
				self.is_idle = True
		else:
			if self.is_idle:
				try:
					self.is_idle = False # important to do this before the cmd_noreply()
					self.cmd_noreply('noidle')
				except MPDException:
					pass

	def unidle(self):
		self.idle(False)

	def update(self):
		ret = self.cmd_noreply('update')
		try:
			if len(ret) != 1:
				raise
			parts = ret[0].split(' ')
			if len(parts) == 2 and parts[0] == 'updating_db:':
				int(parts[1])
			else:
				raise
		except:
			raise MPDException("Invalid MPD update reply: %s" % ret)

	def crossfade(self, n = -1):
		if n == -1:
			if self.statusdict['xfade'] == 0:
				self.cmd_noreply("crossfade %d" % self.xfade)
			else:
				self.cmd_noreply("crossfade 0")
		else:
			self.xfade = n
			self.cmd_noreply("crossfade %d" % self.xfade)

	def set_volume(self, v): self.cmd_noreply("setvol %d" % v)

	def get_playlists(self):
		return map(lambda line: line[10:], filter(lambda line: line[:10] == 'playlist: ', self.cmd('lsinfo')))

	def playlist_append_track(self, name):
		self.cmd_noreply('load "%s"' % name)

	def playlist_clear(self):
		self.cmd_noreply('clear')

	def playlist_save(self, name):
		self.cmd_noreply('save "%s"' % name)

	def playlist_delete(self, name):
		self.cmd_noreply('rm "%s"' % name)

class Screen:
	def __init__(self):
		self.stdscr = curses.initscr()
		curses.start_color()

		self.init_color()

		curses.cbreak()
		curses.noecho()
		self.stdscr.keypad(1)

	def init_color(self):
		curses.use_default_colors()
		curses.init_pair(curses.COLOR_BLACK,   -1,                   -1)
		curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN,   -1)
		curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE,   -1)
		curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED,     -1)
		curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN,    -1)
		curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1)
		curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE,    -1)
		curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW,  -1)

	def teardown(self):
		curses.nocbreak()
		curses.echo()
		curses.endwin()

	def hide(self):
		curses.endwin()

	def refresh(self):
		self.stdscr.refresh()

	def show(self):
		self.refresh()

	def clear(self):
		self.stdscr.clear()

	def status(self, s, **kwargs):
		self.stdscr.move(1, 0)
		self.stdscr.clrtoeol()
		attr = kwargs['color'] if 'color' in kwargs else 0
		self.stdscr.addstr(s, attr)
		if 'update' in kwargs and kwargs['update']:
			self.stdscr.refresh();

	def get_max_y(self):
		return self.get_max_yx()[0]

	def get_max_yx(self):
		return self.stdscr.getmaxyx()

	def get_yx(self):
		return self.stdscr.getyx()
	def set_yx(self, yx):
		self.move(yx[0], yx[1])
	def move(self, y, x):
		self.stdscr.move(y, x)
	def clrtoeol(self):
		self.stdscr.clrtoeol()
	def addstr(self, s, *args):
		self.stdscr.addstr(s, *args)

	def calc_scrolloff(self, wanted):
		drawable_space = self.get_max_y() - STATUS_HEIGHT
		return min(drawable_space / 2, wanted)

	def getchar(self, timeout = 1):
		if timeout:
			self.stdscr.timeout(CURSES_TIMEOUT) # after 100ms, -1 is returned
		else:
			self.stdscr.timeout(-1)

		ch = self.stdscr.getch() # main sleep statement here

		ret = None if ch == -1 else ch

		if not timeout:
			self.stdscr.timeout(CURSES_TIMEOUT)

		return ret

	def prompt(self, str, pw = 0, autocomplete = []):
		self.status(str)
		self.stdscr.move(1, len(str))

		self.stdscr.timeout(-1)

		y, x = self.stdscr.getyx()

		ret = ''
		while True:
			c = self.stdscr.getch()

			try:
				chrd = chr(c)
			except:
				chrd = ''

			if c == ord('\n'):
				break

			elif c == ord('\t') and len(autocomplete):
				autoed = autocomplete_do(autocomplete, ret)
				if autoed != None:
					ret = autoed

			elif c == 033 or c == 31:
				ret = None
				break

			elif c == ctrl_and('u'):
				ret = ''

			elif c == 127 or c == 263 or c == ord('\b'):
				if len(ret):
					ret = ret[:len(ret)-1]
				else:
					ret = None
					break

			elif chrd in string.printable:
				ret += chrd

			self.stdscr.move(y, x)
			self.stdscr.addstr(('*' * len(ret)) if pw else ret)
			self.stdscr.refresh()

		self.stdscr.timeout(CURSES_TIMEOUT)
		return ret

	def confirm(self, prompt):
		self.status(prompt)
		ch = self.getchar(0)
		return ch == ord('\n') or ch == ord('y')

	def scroll_output(self, initial_y, x, lines):
		h, w = self.get_max_yx()

		h -= 1
		w -= 1

		y = initial_y
		for l in lines:
			self.stdscr.addstr(y, x, l[:w - 4])
			y += 1
			if y >= h:
				self.stdscr.addstr(y, x, 'Return for next page...', curses.A_BOLD | curses.color_pair(curses.COLOR_RED))

				while self.getchar(0) != ord('\n'):
					pass
				self.stdscr.clear()
				y = initial_y
		self.refresh()

	def window(self, start_x, start_y, w, h, attr = 0):
		end_x, end_y = start_x + w - 1, start_y + h - 1

		for x in range(start_x, start_x + w):
			for y in range(start_y, start_y + h):
				c = ' '
				if x in (start_x, end_x):
					if y in (start_y, end_y):
						c = '+'
					else:
						c = '|'
				elif y in (start_y, end_y):
					c = '-'
				self.stdscr.addch(y, x, c, attr)

class Mpcpy:
	def __init__(self, mpd, screen):
		self.draw_selected = 0
		self.draw_top = 0
		self.draw_playing = -1
		self.mpd = mpd
		self.screen = screen
		self.marks = {}
		self.mpd_track_time_last_check = 0
		self.mpd_track_time = 0
		self.select_delay = 0
		self.should_exit = False
		self.mpd_track_changed = False
		self.search_rev = 1
		self.search_regex = None
		self.search_str = ''
		self.normal_input = ''
		self.selection = {}

	def lastmark(self):
		self.mark_add(ord("'"), self.draw_selected)

	def mark_add(self, ch, pos):
		self.marks[ch] = pos

	def mark_get(self, ch):
		try:
			return self.marks[ch]
		except:
			return -1

	def view_set(self, n, marklast = True):
		if marklast:
			self.lastmark()

		n = int(n)
		maxy = self.screen.get_max_y() - 2

		if n < 0:
			n = 0
		elif n >= len(self.mpd.playlist):
			n = len(self.mpd.playlist) - 1

		self.draw_selected = n

		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)

		limit_top = self.draw_top + scroll_off
		if limit_top < 0: limit_top = 0
		limit_bot = self.draw_top + maxy - 1 - scroll_off
		if limit_bot < 0: limit_bot = 0

		dtop = None

		if n < limit_top:
			dtop = n - scroll_off
			if dtop < 0: dtop = 0
			self.draw_top = dtop
		elif n > limit_bot:
			dtop = n - maxy + scroll_off
			if dtop >= len(self.mpd.playlist):
				dtop = len(self.mpd.playlist)
			self.draw_top = dtop

		if dtop is not None:
			self.draw_top = dtop

	def view_move_paragraph(self, direction):
		i = self.draw_selected
		curtrack = self.mpd.playlist[i]

		while i >= 0 and i < len(self.mpd.playlist):
			i += direction
			next = self.mpd.playlist[i]
			if try_key(next, 'Artist') != try_key(curtrack, 'Artist'):
				break

		self.view_set(i)

	def exit(self):
		self.should_exit = True

	def input_wait(self):
		if not self.mpd.waiting_on_cmd:
			self.mpd.idle(True)
		# else we're waiting for the cmd response

		while True:
			try:
				ready = select.select([self.mpd.bufsock, sys.stdin], [], [], self.select_delay)
				break
			except select.error as e:
				if e[0] == errno.EINTR:
					continue
				raise e

		if self.mpd.bufsock in ready[0]:
			if self.mpd.waiting_on_cmd:
				self.try_catch_mpd(lambda: self.mpd.resolve_wait())
			else:
				self.handle_idle()

		if sys.stdin in ready[0]:
			self.handle_keys()
			if self.should_exit:
				return False

		# may have timed out, check mpd time
		self.update_time()

		return True

	def update_time(self):
		self.draw_status(self.mpd_track_time)

		now = time.time()
		if now - self.mpd_track_time_last_check > 1:
			self.mpd_track_time_last_check = now
			statusdict = self.mpd.statusdict
			if 'state' in statusdict.keys():
				if statusdict['state'] == 'play':
					self.mpd_track_time += 1
					if self.mpd_track_changed:
						self.mpd_track_changed = False
						self.mpd_track_time = 0
				elif statusdict['state'] == 'stop':
					self.mpd_track_time = 0

	def draw_status(self, time_extra = 0):
		self.select_delay = 1

		oldyx = self.screen.get_yx()

		if 'Title' in self.mpd.current.keys():
			current_song = self.mpd.current['Title']
		elif 'file' in self.mpd.current.keys():
			current_song = self.mpd.current['file']
		else:
			current_song = "<unknown>"

		if 'time' in self.mpd.statusdict.keys():
			play_time = self.mpd.statusdict['time']
		else:
			play_time = '00:00'

		times = play_time.split(':')
		time_now = int(times[0]) + time_extra
		time_fin = int(times[1])

		self.screen.move(0, 0)
		self.screen.clrtoeol()
		self.screen.addstr("%s showing %d/%d, %s: %s %s/%s" % (
			statusstr(self.mpd.statusdict),
			self.draw_selected + 1, len(self.mpd.playlist),
			self.mpd.statusdict['state'], current_song, format_time(time_now), format_time(time_fin)))

		self.screen.set_yx(oldyx)

	def goto_mark(self):
		ch = self.screen.getchar(0)
		pos = mark_get(ch)
		if pos == -1:
			self.screen.status("unset mark")
		else:
			self.view_set(pos, False)

	def create_mark(self):
		ch = self.screen.getchar(0)
		self.mark_add(ch, draw_selected)

		s = '%d' % self.draw_selected
		try:
			s = self.mpd.playlist[self.draw_selected]['Title']
		except:
			pass
		self.screen.status("marked: %c => %s" % (ch, s))

	def screen_position(self, where):
		self.lastmark()
		maxy = self.screen.get_max_y()
		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)
		if where < 0:
			self.draw_selected = self.draw_top + scroll_off
		elif where == 0:
			self.draw_selected = self.draw_top + maxy - scroll_off - 2 # 2 for the status bars
		else:
			self.draw_selected = self.draw_top + maxy / 2 - 1 # for status bar
		self.clip_draw_selected()

	def clip_draw_selected(self):
		if self.draw_selected >= len(self.mpd.playlist):
			self.draw_selected = len(self.mpd.playlist) - 1
		if self.draw_selected < 0:
			self.draw_selected = 0

	def playlist_save(self):
		name = self.screen.prompt('save playlist as: ')
		if name is None:
			return

		try:
			self.mpd.playlist_save(name)
			self.screen.status('saved as %s' % name)
		except MPDException as e:
			if self.screen.confirm('playlist "%s" exists, overwrite? (y/n): ' % name):
				self.mpd.playlist_delete(name)
				self.mpd.playlist_save(name)
				self.screen.status('overwrote playlist %s' % name)
			else:
				self.screen.status('playlist unsaved')

	def try_catch_mpd(self, fn):
		try:
			fn()
		except MPDException as e:
			self.screen.status("%s" % e, color=curses.A_BOLD | curses.color_pair(curses.COLOR_RED))

	def handle_key(self, keystr):
		self.try_catch_mpd(lambda: KEY_DEFINITIONS[keystr](self))

	def handle_keys(self):
		maxy = self.screen.get_max_y()

		ch = self.screen.getchar()
		if ch is None:
			return
		try:
			as_char = chr(ch)
		except ValueError:
			return

		self.normal_input += as_char
		possible = []

		for cmd in KEY_DEFINITIONS:
			if self.normal_input == cmd[:len(self.normal_input)]:
				possible.append(cmd)

		if len(possible) == 0:
			self.screen.status("unknown key %d" % ch)
			self.normal_input = ''
		elif len(possible) == 1:
			self.handle_key(possible[0])
			self.normal_input = ''

	def handle_idle(self):
		# FIXME: this belongs in mpd
		lines = self.mpd.idle_response()

		for l in lines:
			# database
			# update
			# stored_playlist
			# mixer
			# output
			# sticker
			# subscription
			# message

			if l.find('changed: ') == 0:
				l = l[9:]

				old_idx = self.mpd.current_pos()

				if l == 'options':
					# rzxyc options
					self.mpd.update_statusdict()
				elif l == 'playlist':
					self.mpd.update_playlist_diff()
					self.mpd.update_current() # need to update the 'Pos' of playing
					self.clip_draw_selected()
				elif l == 'player' or l == 'mixer':
					# play, pause, etc
					self.mpd.update_statusdict()
					self.mpd.update_current()
				elif l == 'update':
					self.screen.status("mpd update complete")

				if old_idx != self.mpd.current_pos():
					self.mpd_track_changed = True

	def queue(self):
		go = False
		try:
			which = self.mpd.playlist[self.draw_selected]
		except:
			self.screen.status("nothing selected")
			return

		self.screen.hide()

		ret = os.system("mpc-queue -f -%s" % which['Pos'])
		if ret == 0:
			try:
				t = which['Title']
			except:
				t = 'track %s' % which['Pos']
			self.screen.status("queued %s" % t)
		else:
			self.screen.status("queue error!")

	def set_xfade(self):
		s = self.screen.prompt('xfade: ')
		if s != None and len(s):
			try:
				n = int(s)
			except:
				self.screen.status('need number for xfade')
				return
			self.mpd.crossfade(n)
			self.screen.status('xfade set to %d' % mpd_xfade)

	def move_track(self, pos, up):
		if pos > 0 if up else pos < len(self.mpd.playlist)-1:
			to = pos + (-1 if up else 1)
			self.mpd.move(pos, to)
			return True
		return False

	def shift_tracks(self, dir):
		# shift song up or down one
		up = dir == 'up'
		have_selected = len(self.selection) > 0

		if have_selected:
			ids = self.selection.keys()
			to_move = filter(lambda entry: entry['Id'] in ids, self.mpd.playlist)

			if not up:
				to_move.reverse()

			for entry in to_move:
				if not self.move_track(entry['Pos'], up):
					break
		else:
			if self.move_track(self.draw_selected, up):
				self.view_set(self.draw_selected + (-1 if up else 1), False)
			else:
				self.screen.status("can't move from there")

	def toggle_selection(self):
		track = self.mpd.playlist[self.draw_selected]
		id = track['Id']
		if id in self.selection:
			del self.selection[id]
		else:
			self.selection[id] = True
		self.draw_selected += 1
		self.clip_draw_selected()

	def prompt_search(self, reverse):
		self.search_str = self.screen.prompt('?' if reverse else '/')
		if self.search_str is None or len(self.search_str) == 0:
			return None
		return re.compile(".*" + self.search_str + ".*", re.IGNORECASE)

	def search(self, type):
		if type == "forwards" or type == "backwards":
			self.search_rev = 0 if type == "forwards" else 1
			self.search_regex = self.prompt_search(self.search_rev)

		self.lastmark()

		if self.search_regex is not None:
			order_adj = self.search_rev
			if type == "prev":
				order_adj ^= 1
			self.dosearch(order_adj)

	def dosearch(self, reverse):
		if reverse:
			positions_to_search = range(self.draw_selected - 1, -1, -1)
			positions_to_search.extend(i for i in range(len(self.mpd.playlist) - 1, self.draw_selected, -1))
		else:
			positions_to_search = range(self.draw_selected + 1, len(self.mpd.playlist)) 
			positions_to_search.extend(i for i in range(0, self.draw_selected))

		def search_descript(item, items):
			words = []
			for i in items:
				try:
					words.append([item[i], i])
				except:
					pass
			return words

		if self.search_regex is None:
			self.search_regex = self.prompt_search(reverse)
			if self.search_regex is None:
				return

		keys = ['Title', 'Artist', 'Album', 'file']
		for track in [self.mpd.playlist[i] for i in positions_to_search]:
			for key in keys:
				if key in track and self.search_regex.match(track[key]):
					self.view_set(track['Pos'], False)
					self.screen.status("")
					return
		self.screen.status("Couldn't find %s" % self.search_regex)

	def view_current(self):
		self.lastmark()
		curidx = try_key(self.mpd.current, 'Pos', -1)
		if curidx >= 0:
			self.view_set(curidx, False)

	def refresh(self):
		self.screen.status('')
		self.screen.refresh()

	def run(self):
		self.screen.status("Connected to mpd @ %s" % self.mpd.hoststr())

		while True:
			self.draw()
			self.screen.refresh()
			if not self.input_wait():
				break

		self.mpd.close()

	def draw_line(self, i, max_x):
		entry = self.mpd.playlist[i]

		if i == self.draw_selected:
			if i == self.mpd.current_pos():
				# selected _and_ playing
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_YELLOW)
			else:
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)
		elif i == self.mpd.current_pos():
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_RED)
		elif self.mpd.playlist[i]['Id'] in self.selection:
			attr = curses.color_pair(curses.COLOR_BLUE)
		else:
			attr = curses.A_NORMAL

		time   = try_key(entry, 'Time', 0)
		artist = try_key(entry, 'Artist')
		title  = try_key(entry, 'Title')
		album  = try_key(entry, 'Album')

		scale = float(max_x) / float(SPACE_TIME + SPACE_ARTIST + SPACE_TITLE + SPACE_ALBUM)

		time = format_time(time)[:int(SPACE_TIME * scale)]
		artist = artist[:int(SPACE_ARTIST * scale)]
		title = title[:int(SPACE_TITLE * scale)]
		album = album[:int(SPACE_ALBUM * scale)]

		time = "%-*s" % (int(SPACE_TIME * scale), time)

		formatted_str = ("%-*s %-*s %-*s" % (
			int(SPACE_ARTIST * scale), artist,
			int(SPACE_TITLE  * scale), title,
			int(SPACE_ALBUM  * scale), album)).rstrip()

		if len(formatted_str.replace(' ', '')) == 0:
			formatted_str = try_key(entry, 'file', '?')

		together = time + formatted_str
		final = (together[:max_x - 3] + '...') if len(together) > max_x else together

		self.screen.clrtoeol()
		try:
			self.screen.addstr(final, attr)
		except curses.error:
			pass

	def draw(self):
		max_y, max_x = self.screen.get_max_yx()

		initial_i = self.draw_top
		for y, i in zip(range(STATUS_HEIGHT, max_y), range(initial_i, initial_i + max_y)):
			self.screen.move(y, 0)

			if i < len(self.mpd.playlist):
				self.draw_line(i, max_x);
			else:
				self.screen.addstr("~")
				self.screen.clrtoeol()

		self.screen.move(0, 0)

	def seek(self):
		spos = self.screen.prompt('seek to: ')
		if spos == None or len(spos) == 0:
			return
		try:
			if spos.find(':'):
				segments = spos.split(':')
				if len(segments) > 3:
					raise Exception("")
				while len(segments) < 3:
					segments.insert(0, 0)
				pos = int(segments[2]) + int(segments[1]) * 60 + int(segments[0]) * 24 * 60
			else:
				pos = int(spos)
		except:
			self.screen.status("not a valid time")
			return

		self.mpd.seek(pos)

	def playlist_load(self):
		playlists = sorted(self.mpd.get_playlists())

		self.screen.clear()
		self.screen.scroll_output(3, 0, playlists)

		name = self.screen.prompt('playlist: ', autocomplete=playlists)
		if name is None:
			return
		self.mpd.playlist_append_track(name)

	def playlist_clear(self):
		self.mpd.playlist_clear()

	def playlist_remove_current(self):
		if len(self.selection) > 0:
			ids = self.selection.keys()
			to_remove = filter(lambda entry: entry['Id'] in ids, self.mpd.playlist)
			for track in sorted(to_remove, lambda a, b: b['Pos'] - a['Pos']):
				self.mpd.remove(track['Pos'])
		else:
			pos = self.mpd.playlist[self.draw_selected]['Pos']
			self.mpd.remove(pos)

	def password(self):
		pw = self.screen.prompt('password: ', pw=1)
		if pw == None or len(pw) == 0:
			return
		self.mpd.attempt_password(pw)
		self.screen.status('password accepted')

	def info(self, current):
		h, w = self.screen.get_max_yx()

		x = 1
		y = h / 2 - h / 4

		self.screen.window(
				x - 1, y - 1, w, h / 2,
				curses.A_BOLD | curses.color_pair(curses.COLOR_MAGENTA))

		attr = [ 'file', 'Title', 'Artist', 'Album', 'Time', 'Track', 'Genre', 'Pos', 'Id' ]

		x += 1
		i = 1
		for a in attr:
			try:
				val = current[a]
				if a == 'Time':
					val = format_time(val)

				s = a + ': ' + val
				self.screen.addstr(y + i, x, s[:w - 4])
				i += 1
			except:
				pass

		self.screen.addstr(y + len(attr) + 1, x, 'Any key to continue...')
		self.screen.getchar(0)

	def view_scroll(self, inc):
		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)

		if inc > 0:
			max = len(self.mpd.playlist)-1

			if self.draw_top + scroll_off >= max:
				return

			self.draw_top += 1
			y = self.draw_top + scroll_off;
			if y >= self.draw_selected:
				self.draw_selected = y
				if self.draw_selected > max:
					self.draw_selected = max
		else:
			if self.draw_top == 0:
				return
			self.draw_top -= 1
			y = self.draw_top + self.screen.get_max_y() - 2 - scroll_off
			if y < self.draw_selected:
				self.draw_selected = y

	def shellout(self):
		cmd = self.screen.prompt('!')
		if cmd is None:
			return
		if cmd == '':
			cmd = os.environ["SHELL"] or "sh"
		self.screen.hide()
		os.system(cmd)
		sys.stdout.write("(press RETURN)")
		while self.screen.getchar(0) != ord('\n'):
			pass


def main(args):
	if len(args) != 1:
		print >>sys.stderr, "Usage: %s" % args[0]
		sys.exit(2)

	screen = Screen()

	printme = None
	lastexception = None

	try:
		screen.status('Connecting...', update=True)
		mpd = create_mpd(screen)

		mpcpy = Mpcpy(mpd, screen)

		mpcpy.view_current()
		mpcpy.run()
	except MPDException as e:
		printme = "MPDException: %s" % e
	except KeyboardInterrupt as e:
		printme = "interrupted!"
	except Exception as e:
		lastexception = e

	try:
		screen.teardown()
	except Exception:
		pass

	if printme:
		print >>sys.stderr, printme
		sys.exit(1)
	elif lastexception:
		print >>sys.stderr, "caught error during mpcpy execution:"
		import traceback
		traceback.print_exc(lastexception)

main(sys.argv)
