#!/usr/bin/python

import curses
import socket
import sys, errno, os
import re
import time
import string
import select

# const
STATUS_HEIGHT  = 2
SCROLL_OFF     = 10
CURSES_TIMEOUT = 250

# relative differences
SPACE_TIME     = 2
SPACE_ARTIST   = 5
SPACE_TITLE    = 8
SPACE_ALBUM    = 4

# view modes
VIEW_MODE_PLAYLIST = 'playlist'
VIEW_MODE_OUTPUTS = 'outputs'
VIEW_MODE_LIBRARY = 'library'

debug_plchanges = False

from BufRead import BufRead

def ctrl_and(n):
	return chr(ord(n) & 0o37)

def default_set(map, key, val):
	if key not in map.keys():
		map[key] = val

KEY_DEFINITIONS = {
	'': {
		'q': lambda self: self.exit(),
		'j': lambda self: self.view_set(self.draw_selected + 1),
		'k': lambda self: self.view_set(self.draw_selected - 1),
		ctrl_and('d'): lambda self: self.view_set(self.draw_selected + self.screen.get_max_y() / 2),
		ctrl_and('u'): lambda self: self.view_set(self.draw_selected - self.screen.get_max_y() / 2),
		ctrl_and('f'): lambda self: self.view_set(self.draw_selected + self.screen.get_max_y()),
		ctrl_and('b'): lambda self: self.view_set(self.draw_selected - self.screen.get_max_y()),
		ctrl_and('e'): lambda self: self.view_scroll(+1),
		ctrl_and('y'): lambda self: self.view_scroll(-1),

		'!': lambda self: self.shellout(),

		'gg': lambda self: self.view_set(0),
		'G': lambda self: self.view_set(self.view_max() - 1),

		'gs': lambda self: self.seek(),
		'gS': lambda self: self.playlist_save(),
		'gL': lambda self: self.playlist_load(),
		'gC': lambda self: self.playlist_clear(),

		'H': lambda self: self.screen_position(-1),
		'L': lambda self: self.screen_position(0),
		'M': lambda self: self.screen_position(+1),

		'p':  lambda self: self.mpd.toggle(),
		's':  lambda self: self.mpd.stop(),

		'>': lambda self: self.mpd.next(),
		'<': lambda self: self.mpd.prev(),

		'r': lambda self: self.mpd.repeat(),
		'z': lambda self: self.mpd.random(),
		'y': lambda self: self.mpd.single(),
		'c': lambda self: self.mpd.consume(),
		'x': lambda self: self.mpd.crossfade(),

		'X': lambda self: self.set_xfade(),

		'1': lambda self: self.set_view_mode(VIEW_MODE_PLAYLIST),
		'2': lambda self: self.set_view_mode(VIEW_MODE_OUTPUTS),
		'3': lambda self: self.set_view_mode(VIEW_MODE_LIBRARY),

		'P': lambda self: self.password(),
		'u': lambda self: self.mpd.update(),

		'(': lambda self: self.mpd.adj_volume(-1),
		')': lambda self: self.mpd.adj_volume(+1),

		# 12 = "\f" = ctrl+L
		chr(12): lambda self: self.refresh(),
		ctrl_and('['): lambda self: self.escape(),
	},

	VIEW_MODE_PLAYLIST: {
		'"': lambda self: self.goto_mark(),

		'm': lambda self: self.create_mark(),

		'i': lambda self: self.info(self.mpd.playlist[self.draw_selected]),

		'd':  lambda self: self.playlist_remove_current(),
		'\n': lambda self: self.confirm(),

		'f': lambda self: self.seek(+1),
		'b': lambda self: self.seek(-1),

		'Q': lambda self: self.queue(),

		'W': lambda self: self.shift_tracks('up'),
		'w': lambda self: self.shift_tracks('down'),

		' ': lambda self: self.toggle_selection(),

		'/': lambda self: self.search('forwards'),
		'?': lambda self: self.search('backwards'),
		'n': lambda self: self.search('next'),
		'N': lambda self: self.search('prev'),

		'o': lambda self: self.view_current(),

		'{': lambda self: self.view_move_paragraph(-1),
		'}': lambda self: self.view_move_paragraph(+1),
	},

	VIEW_MODE_OUTPUTS: {
		'\n': lambda self: self.mpd.output_toggle(self.draw_selected),
	},

	VIEW_MODE_LIBRARY: {
		'\n': lambda self: self.library_confirm(),
		' ': lambda self: self.library_select(),

		'/': lambda self: self.search('forwards'),
		'?': lambda self: self.search('backwards'),
		'n': lambda self: self.search('next'),
		'N': lambda self: self.search('prev'),
	}
}

def list_to_map(lst):
	curmap = {}
	i = 0
	while i < len(lst):
		pos = lst[i].find(':')
		if pos == -1:
			raise Exception("list_to_map: no colon in line: \"%s\"" % lst[i])

		curmap[lst[i][:pos]] = lst[i][pos+2:]
		i += 1
	return curmap

def try_key(dict, key, default = ''):
	return dict[key] if key in dict.keys() else default

def intify(map, keys, always_set = False):
	for k in keys:
		if always_set or k in map:
			try:
				map[k] = int(map[k])
			except (ValueError, KeyError):
				map[k] = 0
	return map

def intify_playlist_entry(entry):
	return intify(entry, ['Pos', 'Id'])

def re_compile(str):
	return re.compile(".*(" + str + ").*", re.IGNORECASE)

def re_pattern(regex):
	return regex.pattern[3:-3]

def hoststr(host, port):
	return "%s:%s" % (host, port)

def parse_keyval(raw, new_entry_keys = []):
	entries = []
	curmap = {}
	for line in raw:
		colon = line.find(':')
		if colon == -1:
			raise MPDException("no colon in line: \"%s\"" % line)

		key = line[:colon]
		val = line[colon+2:]

		if key in curmap or (len(curmap) and key in new_entry_keys):
			entries.append(curmap)
			curmap = {}

		curmap[key] = val

	if len(curmap) and curmap not in entries:
		entries.append(curmap)

	return entries

def parse_playlist(raw):
	return map(intify_playlist_entry, parse_keyval(raw, ['playlist', 'directory', 'file']))

def format_time(s):
	n = int(s)
	secs = n % 60
	mins = n / 60
	hr = mins / 60
	mins %= 60

	if hr:
		return "%02d:%02d:%02d" % (hr, mins, secs)
	return "%02d:%02d" % (mins, secs)

def flex_str_length(max_length, pre, flex, post):
	used = len(pre) + len(flex) + len(post)
	if used < max_length:
		return len(flex)

	remaining = max_length - used
	return remaining

def even_pad(str, pad, length):
	space = length - len(str)
	extra = '' # keep the length the same
	if space % 2:
		space -= 1
		extra = pad

	return pad * (space / 2) + str + pad * (space / 2) + extra

def statusstr(statusdict):
	return "[%s%s%s%s%s]" % (
			'r' if statusdict['repeat' ] > 0 else '-',
			'z' if statusdict['random' ] > 0 else '-',
			'y' if statusdict['single' ] > 0 else '-',
			'x' if statusdict['xfade'  ] > 0 else '-',
			'c' if statusdict['consume'] > 0 else '-')

def common_prefix(strings, seed):
	common = seed
	i = len(common)
	while True:
		if i >= len(strings[0]):
			break
		ch = strings[0][i]

		match = True
		for other in strings:
			if i >= len(other) or other[i] != ch:
				match = False
				break

		if not match:
			break

		common += ch
		i += 1
	return common

def autocomplete_do(all, str):
	str_len = len(str)
	chosen = []

	for i in all:
		if i[:str_len] == str:
			chosen.append(i)

	if len(chosen) == 1:
		return chosen[0]

	if len(chosen) == 0:
		return str

	return common_prefix(chosen, str)

# ----------------------------------------------------
# socket/mpd code

class MpcpyException(Exception):
	pass
class MPDException(Exception):
	pass

def create_mpd(screen):
	host = os.getenv('MPD_HOST', '') or 'localhost'
	port = os.getenv('MPD_PORT', '') or '6600'
	if host.find("@") != -1:
		parts = host.split("@", 1)
		pw = parts[0]
		host = parts[1]
	else:
		pw = ''

	try:
		port = int(port)
	except ValueError as e:
		raise MPDException("Couldn't parse port (%s): %s" % (port, e))


	sock = socket.socket()
	try:
		sock.connect((host, port))
	except Exception as e:
		raise MPDException("Couldn't connect to mpd @ %s - %s" % (hoststr(host, port), e))

	bufsock = BufRead(sock)

	firstline = bufsock.readLine()
	version_data = firstline.split()

	if len(version_data) != 3 or version_data[0] != 'OK' or version_data[1] != 'MPD':
		raise MPDException("Invalid string from mpd: %s" % firstline)

	vers = version_data[2].split('.')
	if len(vers) != 3:
		raise MPDException("Invalid version string from mpd: %s" % version_data[2])

	try:
		valid_version = int(vers[0]) == 0 and (16 <= int(vers[1]) and int(vers[1]) <= 21)

		if not valid_version and not screen.confirm("MPD (%s) version: %s, continue? (Y/n) " % (hoststr(host, port), version_data[2])):
			raise MPDException("Invalid MPD version: %s" % version_data[2])
	except TypeError as e:
		raise MPDException("Invalid version string from mpd: %s" % version_data[2])

	return Mpd(host, port, pw, bufsock)


class Mpd:
	def __init__(self, host, port, pw, bufsock):
		self.host = host
		self.port = port
		self.bufsock = bufsock
		self.playlist = []
		self.outputs = []
		self.current = {}
		self.statusdict = {}
		self.xfade = 5
		self.waiting_on_cmd = ''
		self.is_idle = False
		if len(pw):
			self.attempt_password(pw)
		self.update_current()
		self.update_statusdict()
		self.update_playlist_full()
		self.update_outputs()

	def hoststr(self):
		return hoststr(self.host, self.port)

	def close(self):
		self.bufsock.close()

	def cmd_raw(self, cmd):
		if self.waiting_on_cmd:
			raise MPDException("still waiting on a previous command (\"{0}\")".format(self.waiting_on_cmd))
		self.unidle()
		self.bufsock.send(cmd + '\n')

	def readlines(self, prevcmd):
		lines = []

		while True:
			got = self.bufsock.readLine()

			if len(got) == 0:
				raise MPDException("mpd connection closed")

			if got == 'OK':
				return lines
			elif got[:3] == 'ACK':
				if prevcmd.find('password') == 0:
					extra = ''
				else:
					extra = ' (from "%s")' % prevcmd
				raise MPDException("MPD error: %s%s" % (got, extra))

			lines.append(got)

	def idle_response(self):
		self.is_idle = False
		return self.readlines('<unidling>')

	def current_pos(self):
		return try_key(self.current, 'Pos') if self.current else -1

	def cmd(self, cmd):
		"""Send 'cmd' to mpd, and read lines until we get an 'OK'"""
		self.cmd_raw(cmd)
		return self.readlines(cmd)

	def cmd_noreply(self, cmd, **kwargs):
		if 'nowait' in kwargs and kwargs['nowait']:
			self.cmd_raw(cmd)
			self.waiting_on_cmd = cmd
		else:
			ret = self.cmd(cmd)
			self.check_noreply(ret)

	def check_noreply(self, lines):
		if len(lines) != 0:
			raise MPDException("Invalid MPD reply: %s" % lines[0])

	def resolve_wait(self):
		cmd = self.waiting_on_cmd
		self.waiting_on_cmd = ''
		lines = self.readlines(cmd)
		self.check_noreply(lines)

	def handle_input(self):
		if self.waiting_on_cmd:
			self.resolve_wait()
			return []
		else:
			return self.handle_idle()

	def handle_idle(self):
		lines = self.idle_response()

		events = []

		for l in lines:
			# database
			# update
			# stored_playlist
			# mixer
			# output
			# sticker
			# subscription
			# message

			if l.find('changed: ') == 0:
				l = l[9:]

				if l == 'options':
					# rzxyc options
					self.update_statusdict()
				elif l == 'playlist':
					self.update_playlist_diff()
					self.update_current() # need to update the 'Pos' of playing
					events.append('playlist')
				elif l == 'mixer':
					self.update_statusdict()
				elif l == 'player':
					# play, pause, etc
					self.update_statusdict()
					self.update_current()
				elif l == 'update':
					events.append('update')
				elif l == 'output':
					self.update_outputs()

		return events

	def update_statusdict(self):
		statusdict = list_to_map(self.cmd("status"))

		default_set(statusdict, 'status', 'stop')
		default_set(statusdict, 'playlist', -1)
		default_set(statusdict, 'playlistlength', -1)
		default_set(statusdict, 'state', 'stop')

		previous_time = try_key(statusdict, 'time', '00:00')
		default_set(statusdict, 'time', '00:00')
		if statusdict['time'] != previous_time:
			self.mpd_track_time = 0

		statusdict = intify(statusdict, ['random', 'repeat', 'consume', 'xfade', 'single', 'volume', 'playlistlength'], True)
		self.statusdict = statusdict

	def update_current(self):
		self.current = intify_playlist_entry(list_to_map(self.cmd("currentsong")))

	def update_playlist_full(self):
		self.playlist = parse_playlist(self.cmd("playlistinfo"))
		self.last_diffed_playlist = self.statusdict['playlist']

	def update_playlist_diff(self):
		playlist_changes = self.cmd('plchanges %s' % self.last_diffed_playlist)
		self.update_statusdict() # for status.playlistlength
		self.last_diffed_playlist = self.statusdict['playlist']

		old_length = len(self.playlist)
		new_length = int(self.statusdict['playlistlength'])

		changed_tracks = parse_playlist(playlist_changes)

		if debug_plchanges:
			print >>sys.stderr, "old_length = {0}".format(old_length)
			print >>sys.stderr, "new_length = {0}".format(new_length)
			print >>sys.stderr, "orig playlist:"
			for track in self.playlist:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])
			print >>sys.stderr, "changed_tracks:"

		for track in changed_tracks:
			if debug_plchanges:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])

			pos = track['Pos']
			if pos < old_length:
				if track['Id'] != self.playlist[pos]['Id']:
					self.playlist[pos] = track
			else:
				self.playlist.append(track)

		if new_length == 0:
			self.playlist = []
		else:
			self.playlist = self.playlist[:new_length]

		self.playlist = sorted(self.playlist, key=lambda track: track['Pos'])

		if debug_plchanges:
			print >>sys.stderr, "new playlist:"
			for track in self.playlist:
				print >>sys.stderr, "  .id={0} .pos={1} .file={2}".format(track['Id'], track['Pos'], track['file'])

	def update_outputs(self):
		self.outputs = parse_keyval(self.cmd('outputs'))

	def output_toggle(self, i):
		output = self.outputs[i]
		if int(output['outputenabled']):
			self.cmd('disableoutput "{0}"'.format(i));
		else:
			self.cmd('enableoutput "{0}"'.format(i));

	def play(self, i = -1):
		if i != -1:
			self.cmd_noreply("play %d" % i, nowait=True)
		else:
			self.cmd_noreply("play", nowait=True)

	def pause(self):      self.cmd_noreply("pause")
	def stop(self):       self.cmd_noreply("stop")
	def prev(self):       self.cmd_noreply("previous")
	def next(self):       self.cmd_noreply("next")
	def stop(self):       self.cmd_noreply("stop")

	def seek(self, pos):
		idx = self.current_pos()
		if idx >= 0:
			self.cmd_noreply("seek {0} {1}".format(idx, pos))

	def toggle(self): self.stop() if self.statusdict['state'] == 'play' else self.play()
	def remove(self, n): self.cmd_noreply("delete %d" % n)
	def add(self, path):
		self.cmd_noreply("add \"%s\"" % path)

	def random(self):  self.cmd_noreply("random %d"  % (1 - self.statusdict['random']))
	def repeat(self):  self.cmd_noreply("repeat %d"  % (1 - self.statusdict['repeat']))
	def consume(self): self.cmd_noreply("consume %d" % (1 - self.statusdict['consume']))
	def single(self):  self.cmd_noreply("single %d"  % (1 - self.statusdict['single']))
	def attempt_password(self, pw): self.cmd_noreply('password "%s"' % pw)
	def move(self, a, b): self.cmd_noreply('move "%s" "%s"' % (a, b))

	def idle(self, on):
		if on:
			if not self.is_idle:
				self.cmd_raw('idle')
				self.is_idle = True
		else:
			if self.is_idle:
				try:
					self.is_idle = False # important to do this before the cmd_noreply()
					self.cmd_noreply('noidle')
				except MPDException:
					pass

	def unidle(self):
		self.idle(False)

	def update(self):
		ret = self.cmd_noreply('update')
		try:
			if len(ret) != 1:
				raise
			parts = ret[0].split(' ')
			if len(parts) == 2 and parts[0] == 'updating_db:':
				int(parts[1])
			else:
				raise
		except:
			raise MPDException("Invalid MPD update reply: %s" % ret)

	def crossfade(self, n = -1):
		if n == -1:
			if self.statusdict['xfade'] == 0:
				self.cmd_noreply("crossfade %d" % self.xfade)
			else:
				self.cmd_noreply("crossfade 0")
		else:
			self.xfade = n
			self.cmd_noreply("crossfade %d" % self.xfade)

	def adj_volume(self, adj):
		v = self.statusdict['volume'] + adj
		if v > 100 or v < 0:
			return
		self.cmd_noreply("setvol %d" % v)

	def lsinfo_raw(self, path):
		return self.cmd('lsinfo "%s"' % path)

	def lsinfo(self, path = ''):
		return parse_playlist(self.lsinfo_raw(path))

	def get_playlists(self):
		return map(lambda line: line[10:], filter(lambda line: line[:10] == 'playlist: ', self.lsinfo_raw()))

	def playlist_append_track(self, name):
		self.cmd_noreply('load "%s"' % name)

	def playlist_clear(self):
		self.cmd_noreply('clear')

	def playlist_save(self, name):
		self.cmd_noreply('save "%s"' % name)

	def playlist_delete(self, name):
		self.cmd_noreply('rm "%s"' % name)

class Screen:
	def __init__(self):
		self.stdscr = curses.initscr()
		curses.start_color()

		self.init_color()

		curses.cbreak()
		curses.noecho()
		self.stdscr.keypad(1)

	def init_color(self):
		curses.use_default_colors()
		curses.init_pair(curses.COLOR_BLACK,   -1,                   -1)
		curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN,   -1)
		curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE,   -1)
		curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED,     -1)
		curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN,    -1)
		curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1)
		curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE,    -1)
		curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW,  -1)

	def teardown(self):
		curses.nocbreak()
		curses.echo()
		curses.endwin()

	def hide(self):
		curses.endwin()

	def refresh(self):
		self.stdscr.refresh()

	def show(self):
		self.refresh()

	def clear(self):
		self.stdscr.clear()

	def status(self, s, **kwargs):
		self.stdscr.move(1, 0)
		self.stdscr.clrtoeol()
		attr = kwargs['color'] if 'color' in kwargs else 0
		self.stdscr.addstr(s, attr)
		if 'update' in kwargs and kwargs['update']:
			self.stdscr.refresh();

	def get_max_y(self):
		return self.get_max_yx()[0]

	def get_max_yx(self):
		return self.stdscr.getmaxyx()

	def get_yx(self):
		return self.stdscr.getyx()
	def set_yx(self, yx):
		self.stdscr.move(yx[0], yx[1])
	def clrtoeol(self):
		self.stdscr.clrtoeol()
	def addstr(self, s, *args):
		self.stdscr.addstr(s, *args)

	def calc_scrolloff(self, wanted):
		drawable_space = self.get_max_y() - STATUS_HEIGHT
		return min(drawable_space / 2, wanted)

	def getchar(self, timeout = 1):
		if timeout:
			self.stdscr.timeout(CURSES_TIMEOUT) # after 100ms, -1 is returned
		else:
			self.stdscr.timeout(-1)

		ch = self.stdscr.getch() # main sleep statement here

		ret = None if ch == -1 else ch

		if not timeout:
			self.stdscr.timeout(CURSES_TIMEOUT)

		return ret

	def prompt(self, str, **kwargs):
		pw = try_key(kwargs, "pw", False)
		autocomplete = try_key(kwargs, "autocomplete", [])
		allow_empty = try_key(kwargs, "allow_empty", False)
		format = try_key(kwargs, "format", "")

		self.stdscr.timeout(-1)
		self.status(str)

		y, x = 1, len(str)
		ret = ''

		while True:
			self.stdscr.move(y, x)
			self.stdscr.addstr(('*' * len(ret)) if pw else ret + " " + format)
			self.stdscr.clrtoeol()
			self.stdscr.move(y, x + len(ret))

			as_int = self.stdscr.getch()

			try:
				as_char = chr(as_int)
			except:
				as_char = ''

			if as_int == ord('\n'):
				break

			elif as_int == ord('\t') and len(autocomplete):
				autoed = autocomplete_do(autocomplete, ret)
				if autoed != None:
					ret = autoed

			elif as_int == 033 or as_int == 31:
				ret = None
				break

			elif as_char == ctrl_and('u'):
				ret = ''

			elif as_int == 127 or as_int == 263 or as_int == ord('\b'):
				if len(ret):
					ret = ret[:len(ret)-1]

			elif as_char in string.printable:
				ret += as_char

		self.stdscr.timeout(CURSES_TIMEOUT)
		if allow_empty and len(ret) == 0:
			return ret;
		return ret or None

	def confirm(self, prompt):
		self.status(prompt)
		ch = self.getchar(0)
		return ch == ord('\n') or ch == ord('y')

	def scroll_output(self, initial_y, x, lines):
		h, w = self.get_max_yx()

		h -= 1
		w -= 1

		y = initial_y
		for l in lines:
			self.stdscr.addstr(y, x, l[:w - 4])
			y += 1
			if y >= h:
				self.stdscr.addstr(y, x, 'Return for next page...', curses.A_BOLD | curses.color_pair(curses.COLOR_RED))

				while self.getchar(0) != ord('\n'):
					pass
				self.stdscr.clear()
				y = initial_y
		self.refresh()

	def window(self, start_x, start_y, w, h, attr = 0):
		end_x, end_y = start_x + w - 1, start_y + h - 1

		for x in range(start_x, start_x + w):
			for y in range(start_y, start_y + h):
				c = ' '
				if x in (start_x, end_x):
					if y in (start_y, end_y):
						c = '+'
					else:
						c = '|'
				elif y in (start_y, end_y):
					c = '-'
				self.stdscr.addch(y, x, c, attr)

class Library:
	def __init__(self, mpd):
		self.mpd = mpd
		self.cache = {}
		self.current_dir = []
		self.path = []

	def is_empty(self):
		return len(self.cache) == 0

	def setcwd(self, path):
		if path == '..':
			if len(self.path):
				self.path.pop()
		elif path == '':
			del self.path[:]
		else:
			self.path = path.split('/')

		self.fetch()

	def fetch(self):
		path = "/".join(self.path)

		if path in self.cache and len(self.cache[path]):
			self.current_dir = self.cache[path]
			return

		ents = self.mpd.lsinfo(path)
		self.current_dir = ents
		self.cache[path] = ents

class Mpcpy:
	class DrawState:
		def __init__(self, mpcpy):
			self.sel = mpcpy.draw_selected
			self.top = mpcpy.draw_top
		def restore(self, mpcpy):
			mpcpy.draw_selected = self.sel
			mpcpy.draw_top = self.top

	def __init__(self, mpd, screen):
		self.draw_selected = 0
		self.draw_saved = {}
		self.draw_top = 0
		self.mpd = mpd
		self.screen = screen
		self.marks = {}
		self.mpd_track_time_last_check = 0
		self.mpd_track_time = 0
		self.select_delay = 0
		self.should_exit = False
		self.mpd_track_pos = -1
		self.search_rev = 1
		self.search_regex = None
		self.normal_input = ''
		self.selection = {}
		self.view_mode = VIEW_MODE_PLAYLIST
		self.interactive_seek = None
		self.library = Library(mpd)

	def lastmark(self):
		self.mark_add(ord("'"), self.draw_selected)

	def mark_add(self, ch, pos):
		self.marks[ch] = pos

	def mark_get(self, ch):
		try:
			return self.marks[ch]
		except:
			return -1

	def view_max(self):
		if self.view_mode == VIEW_MODE_PLAYLIST:
			return len(self.mpd.playlist)
		if self.view_mode == VIEW_MODE_OUTPUTS:
			return len(self.mpd.outputs)
		if self.view_mode == VIEW_MODE_LIBRARY:
			return len(self.library.current_dir) + 1 # +1 for ".."
		return 0

	def view_set(self, n, marklast = True):
		if marklast:
			self.lastmark()

		maxy = self.screen.get_max_y() - 2

		if n < 0:
			n = 0
		elif n >= self.view_max():
			n = self.view_max() - 1

		self.draw_selected = n

		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)

		limit_top = self.draw_top + scroll_off
		if limit_top < 0: limit_top = 0
		limit_bot = self.draw_top + maxy - 1 - scroll_off
		if limit_bot < 0: limit_bot = 0

		dtop = None

		if n < limit_top:
			dtop = n - scroll_off
			if dtop < 0: dtop = 0
			self.draw_top = dtop
		elif n > limit_bot:
			dtop = n - maxy + scroll_off
			if dtop >= self.view_max():
				dtop = self.view_max()
			self.draw_top = dtop

		if dtop is not None:
			self.draw_top = dtop

	def view_move_paragraph(self, direction):
		i = self.draw_selected
		curtrack = self.mpd.playlist[i]

		while True:
			i += direction
			if i not in range(0, len(self.mpd.playlist)):
				break

			next = self.mpd.playlist[i]
			if try_key(next, 'Artist') != try_key(curtrack, 'Artist'):
				break

		if i in range(0, len(self.mpd.playlist)):
			self.view_set(i)

	def exit(self):
		self.should_exit = True

	def input_wait(self):
		if not self.mpd.waiting_on_cmd:
			self.mpd.idle(True)
		# else we're waiting for the cmd response

		while True:
			try:
				ready = select.select([self.mpd.bufsock, sys.stdin], [], [], self.select_delay)
				break
			except select.error as e:
				if e[0] == errno.EINTR:
					continue
				raise e

		if self.mpd.bufsock in ready[0]:
			events = self.try_catch_mpd(lambda: self.mpd.handle_input())
			if events:
				if 'playlist' in events:
					self.clip_draw_selected()
				if 'update' in events:
					self.screen.status("mpd update complete")

		if sys.stdin in ready[0]:
			self.handle_keys()
			if self.should_exit:
				return False

		# may have timed out, check mpd time
		self.update_time()

		return True

	def update_time(self):
		self.draw_status()

		now = time.time()
		diff = now - self.mpd_track_time_last_check
		if diff > 1:
			self.mpd_track_time_last_check = now
			statusdict = self.mpd.statusdict
			if 'state' in statusdict.keys():
				if statusdict['state'] == 'play':
					self.mpd_track_time += diff
					if self.mpd.current_pos() != self.mpd_track_pos:
						self.mpd_track_pos = self.mpd.current_pos()
						self.mpd_track_time = 0
				elif statusdict['state'] == 'stop':
					self.mpd_track_time = 0

	def draw_status(self):
		self.select_delay = 1

		oldyx = self.screen.get_yx()

		if 'Title' in self.mpd.current.keys():
			current_song = self.mpd.current['Title']
		elif 'file' in self.mpd.current.keys():
			current_song = self.mpd.current['file']
		else:
			current_song = "<unknown>"

		time_now, time_fin = self.get_mpd_times()

		pre = "%s showing %d/%d, %s: " % (
			statusstr(self.mpd.statusdict),
			self.draw_selected + 1, self.view_max(),
			self.mpd.statusdict['state']
		)
		post = " %s/%s %s%%" % (
			format_time(time_now), format_time(time_fin),
			self.mpd.statusdict['volume']
		)
		songlen = flex_str_length(self.screen.get_max_yx()[1], pre, current_song, post)

		self.screen.set_yx((0, 0))
		self.screen.clrtoeol()
		self.screen.addstr(pre)
		self.screen.addstr(current_song[:songlen], curses.A_BOLD)
		self.screen.addstr(post)

		if self.interactive_seek is not None:
			self.draw_interactive_seek(time_fin)

		self.screen.set_yx(oldyx)

	def draw_interactive_seek(self, time_fin):
		self.screen.set_yx((1, 0))
		max_y, max_x = self.screen.get_max_yx()

		max_x -= 25 # length("seek: [>] (ESC to cancel)")

		if time_fin == 0:
			percent = 0
		else:
			percent = float(self.interactive_seek) / time_fin
		before = int(percent * max_x)
		after = int((1 - percent) * max_x)

		while before + after < max_x:
			after += 1

		before_str = "=" * before
		after_str = "-" * after
		time_str = format_time(self.interactive_seek)

		if len(before_str) > len(time_str) + 2:
			before_str = even_pad(time_str, "=", len(before_str))
		elif len(after_str) > len(time_str) + 2:
			after_str = even_pad(time_str, "-", len(after_str))

		self.screen.addstr(
				"seek: ["
				+ before_str
				+ ">"
				+ after_str
				+ "] (ESC to cancel)",
				curses.A_BOLD)

	def get_mpd_times(self):
		if 'time' in self.mpd.statusdict.keys():
			play_time = self.mpd.statusdict['time']
		else:
			play_time = '00:00'

		times = play_time.split(':')
		time_now = int(times[0]) + self.mpd_track_time
		time_fin = int(times[1])

		return time_now, time_fin

	def goto_mark(self):
		ch = self.screen.getchar(0)
		pos = mark_get(ch)
		if pos == -1:
			self.screen.status("unset mark")
		else:
			self.view_set(pos, False)

	def create_mark(self):
		ch = self.screen.getchar(0)
		self.mark_add(ch, self.draw_selected)

		s = '%d' % self.draw_selected
		try:
			s = self.mpd.playlist[self.draw_selected]['Title']
		except KeyError:
			pass
		self.screen.status("marked: %c => %s" % (ch, s))

	def screen_position(self, where):
		self.lastmark()
		maxy = self.screen.get_max_y()
		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)
		if where < 0:
			self.draw_selected = self.draw_top + scroll_off
		elif where == 0:
			self.draw_selected = self.draw_top + maxy - scroll_off - 2 # 2 for the status bars
		else:
			self.draw_selected = self.draw_top + maxy / 2 - 1 # for status bar
		self.clip_draw_selected()

	def clip_draw_selected(self):
		if self.draw_selected >= len(self.mpd.playlist):
			self.draw_selected = len(self.mpd.playlist) - 1
		if self.draw_selected < 0:
			self.draw_selected = 0

	def playlist_save(self):
		name = self.screen.prompt('save playlist as: ')
		if name is None:
			return

		try:
			self.mpd.playlist_save(name)
			self.screen.status('saved as %s' % name)
		except MPDException as e:
			if self.screen.confirm('playlist "%s" exists, overwrite? (y/n): ' % name):
				self.mpd.playlist_delete(name)
				self.mpd.playlist_save(name)
				self.screen.status('overwrote playlist %s' % name)
			else:
				self.screen.status('playlist unsaved')

	def try_catch_mpd(self, fn):
		try:
			return fn()
		except MPDException as e:
			self.screen.status("%s" % e, color=curses.A_BOLD | curses.color_pair(curses.COLOR_RED))

	def handle_key(self, keydef):
		self.try_catch_mpd(lambda: keydef(self))

	def handle_keys(self):
		maxy = self.screen.get_max_y()

		ch = self.screen.getchar()
		if ch is None:
			return
		try:
			as_char = chr(ch)
		except ValueError:
			return

		self.normal_input += as_char
		possible = []

		key_defs = dict(KEY_DEFINITIONS[''].items() + KEY_DEFINITIONS[self.view_mode].items())

		for cmd in key_defs:
			if self.normal_input == cmd[:len(self.normal_input)]:
				possible.append(cmd)

		if len(possible) == 0:
			self.screen.status("unknown key %d" % ch)
			self.normal_input = ''
		elif len(possible) == 1:
			self.handle_key(key_defs[possible[0]])
			self.normal_input = ''

	def queue(self):
		go = False
		try:
			which = self.mpd.playlist[self.draw_selected]
		except:
			self.screen.status("nothing selected")
			return

		self.screen.hide()

		ret = os.system("mpc-queue -f -%s" % which['Pos'])
		if ret == 0:
			try:
				t = which['Title']
			except:
				t = 'track %s' % which['Pos']
			self.screen.status("queued %s" % t)
		else:
			self.screen.status("queue error!")

	def set_xfade(self):
		s = self.screen.prompt('xfade: ')
		if s != None:
			try:
				n = int(s)
			except:
				self.screen.status('need number for xfade')
				return
			self.mpd.crossfade(n)
			self.screen.status('xfade set to %d' % mpd_xfade)

	def move_track(self, pos, up):
		if pos > 0 if up else pos < len(self.mpd.playlist)-1:
			to = pos + (-1 if up else 1)
			self.mpd.move(pos, to)
			return True
		return False

	def shift_tracks(self, dir):
		# shift song up or down one
		up = dir == 'up'
		have_selected = len(self.selection) > 0

		if have_selected:
			ids = self.selection.keys()
			to_move = filter(lambda entry: entry['Id'] in ids, self.mpd.playlist)

			if not up:
				to_move.reverse()

			for entry in to_move:
				if not self.move_track(entry['Pos'], up):
					break
		else:
			if self.move_track(self.draw_selected, up):
				self.view_set(self.draw_selected + (-1 if up else 1), False)
			else:
				self.screen.status("can't move from there")

	def toggle_selection(self):
		track = self.mpd.playlist[self.draw_selected]
		id = track['Id']
		if id in self.selection:
			del self.selection[id]
		else:
			self.selection[id] = True
		self.draw_selected += 1
		self.clip_draw_selected()

	def prompt_search(self, reverse):
		search_str = self.screen.prompt('?' if reverse else '/')
		if search_str is None:
			return None
		return re_compile(search_str)

	def search(self, type):
		if type == "forwards" or type == "backwards":
			self.search_rev = 0 if type == "forwards" else 1
			self.search_regex = self.prompt_search(self.search_rev)

		self.lastmark()

		if self.search_regex is not None:
			order_adj = self.search_rev
			if type == "prev":
				order_adj ^= 1
			self.dosearch(order_adj)

	def dosearch(self, reverse):
		if self.view_mode == VIEW_MODE_PLAYLIST:
			keys = ['Title', 'Artist', 'Album', 'file']
			entries = self.mpd.playlist
		elif self.view_mode == VIEW_MODE_LIBRARY:
			keys = ['file', 'playlist', 'directory']
			entries = []
			for ent, i in zip(self.library.current_dir, range(len(self.library.current_dir))):
				new = ent.copy()
				new['Pos'] = i + 1
				entries.append(new)

		if reverse:
			positions_to_search = range(self.draw_selected - 1, -1, -1)
			positions_to_search.extend(i for i in range(len(entries) - 1, self.draw_selected, -1))
		else:
			positions_to_search = range(self.draw_selected + 1, len(entries)) 
			positions_to_search.extend(i for i in range(0, self.draw_selected))

		def search_descript(item, items):
			words = []
			for i in items:
				try:
					words.append([item[i], i])
				except:
					pass
			return words

		if self.search_regex is None:
			self.search_regex = self.prompt_search(reverse)
			if self.search_regex is None:
				return

		for entry in [entries[i] for i in positions_to_search]:
			for key in keys:
				if key in entry and self.search_regex.match(entry[key]):
					self.view_set(entry['Pos'], False)
					self.screen.status("")
					return
		self.screen.status("Couldn't find /%s/" % re_pattern(self.search_regex))

	def set_view_mode(self, mode):
		self.draw_saved[self.view_mode] = Mpcpy.DrawState(self)
		self.view_mode = mode
		if self.view_mode in self.draw_saved:
			self.draw_saved[self.view_mode].restore(self)
		else:
			self.draw_selected = 0
			self.draw_top = 0

		if mode == VIEW_MODE_LIBRARY and self.library.is_empty():
			self.library.setcwd('')

	def library_confirm(self):
		to = self.draw_selected
		self.draw_selected = 1
		self.draw_top = 0

		if to == 0:
			self.library.setcwd('..')
			return

		ent = self.library.current_dir[to - 1]
		if 'directory' in ent:
			self.library.setcwd(ent['directory'])
		elif 'file' in ent:
			path = ent['file']
			self.mpd.add(path)
			self.mpd.play(len(self.mpd.playlist))
			self.view_set(self.draw_selected + 1)
			self.screen.status("added and playing \"%s\"" % path)
		elif 'playlist' in ent:
			playlist = ent['playlist']
			self.mpd.playlist_clear()
			self.mpd.playlist_append_track(playlist)
			self.mpd.play(0)
			self.view_set(self.draw_selected + 1)
			self.screen.status('playing playlist "%s"' % playlist)

	def library_select(self):
		if self.draw_selected == 0:
			self.screen.status('can\'t select ".."')
			return

		ent = self.library.current_dir[self.draw_selected - 1]
		if 'directory' in ent:
			self.screen.status('can\'t select a directory')
		elif 'file' in ent:
			path = ent['file']
			self.mpd.add(path)
			self.view_set(self.draw_selected + 1)
			self.screen.status("added \"%s\"" % path)
		elif 'playlist' in ent:
			playlist = ent['playlist']
			self.mpd.playlist_append_track(playlist)
			self.view_set(self.draw_selected + 1)
			self.screen.status('appended playlist "%s"' % playlist)

	def view_current(self):
		self.lastmark()
		curidx = try_key(self.mpd.current, 'Pos', -1)
		if curidx >= 0:
			self.view_set(curidx, False)

	def refresh(self):
		self.screen.status('')
		self.screen.refresh()

	def run(self):
		self.screen.status("Connected to mpd @ %s" % self.mpd.hoststr())

		while True:
			self.draw()
			self.screen.refresh()
			if not self.input_wait():
				break

		self.mpd.close()

	def draw_line(self, i, max_x):
		if self.view_mode == VIEW_MODE_PLAYLIST:
			self.draw_line_playlist(i, max_x)
		elif self.view_mode == VIEW_MODE_OUTPUTS:
			self.draw_line_output(i, max_x)
		elif self.view_mode == VIEW_MODE_LIBRARY:
			self.draw_line_library(i, max_x)

	def draw_line_output(self, i, max_x):
		if i >= len(self.mpd.outputs):
			self.screen.addstr("~")
			self.screen.clrtoeol()
			return

		output = self.mpd.outputs[i]

		id = output['outputid']
		name = output['outputname']
		enabled = int(output['outputenabled']) != 0

		attr = 0
		if self.draw_selected == i:
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)
		elif enabled:
			attr = curses.color_pair(curses.COLOR_BLUE)

		self.screen.clrtoeol()
		self.screen.addstr("Output {0}: {1}{2}".format(id, name, " (disabled)" if not enabled else ""), attr)

	def draw_line_playlist(self, i, max_x):
		if i >= len(self.mpd.playlist):
			self.screen.addstr("~")
			self.screen.clrtoeol()
			return

		entry = self.mpd.playlist[i]

		if i == self.draw_selected:
			if entry['Pos'] == self.mpd.current_pos():
				# selected _and_ playing
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_YELLOW)
			else:
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)
		elif entry['Pos'] == self.mpd.current_pos():
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_RED)
		elif entry['Id'] in self.selection:
			attr = curses.color_pair(curses.COLOR_BLUE)
		else:
			attr = curses.A_NORMAL

		time   = try_key(entry, 'Time', 0)
		artist = try_key(entry, 'Artist')
		title  = try_key(entry, 'Title')
		album  = try_key(entry, 'Album')

		scale = float(max_x) / float(SPACE_TIME + SPACE_ARTIST + SPACE_TITLE + SPACE_ALBUM)

		time = format_time(time)[:int(SPACE_TIME * scale)]
		artist = artist[:int(SPACE_ARTIST * scale)]
		title = title[:int(SPACE_TITLE * scale)]
		album = album[:int(SPACE_ALBUM * scale)]

		time = "%-*s" % (int(SPACE_TIME * scale), time)

		formatted_str = ("%-*s %-*s %-*s" % (
			int(SPACE_ARTIST * scale), artist,
			int(SPACE_TITLE  * scale), title,
			int(SPACE_ALBUM  * scale), album)).rstrip()

		if len(formatted_str.replace(' ', '')) == 0:
			formatted_str = try_key(entry, 'file', '?')

		together = time + formatted_str
		final = (together[:max_x - 3] + '...') if len(together) > max_x else together

		self.screen.clrtoeol()
		try:
			self.screen.addstr(final, attr)
		except curses.error:
			pass

	def draw_line_library(self, i, max_x):
		if i >= len(self.library.current_dir) + 1:
			self.screen.addstr("~")
			self.screen.clrtoeol()
			return

		if i == 0:
			fname = '..'
		else:
			ent = self.library.current_dir[i - 1]
			if 'directory' in ent:
				fname = ent['directory'] + '/'
			elif 'file' in ent:
				fname = ent['file']
			elif 'playlist' in ent:
				fname = 'playlist: ' + ent['playlist']
			else:
				fname = '<unknown entry: ' + ','.join(ent.keys()) + '>'

		attr = 0
		if self.draw_selected == i:
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)

		self.screen.clrtoeol()
		try:
			self.screen.addstr(fname, attr)
		except curses.error:
			pass

	def draw(self):
		max_y, max_x = self.screen.get_max_yx()

		initial_i = self.draw_top
		for y, i in zip(range(STATUS_HEIGHT, max_y), range(initial_i, initial_i + max_y)):
			self.screen.set_yx((y, 0))
			self.draw_line(i, max_x)
		self.screen.set_yx((0, 0))

	def seek(self, interactive_dir = None):
		if interactive_dir is None:
			if self.interactive_seek is not None:
				self.interactive_seek = None
			return self.seek_prompt()

		time_now, time_fin = self.get_mpd_times()
		if time_fin == 0:
			self.screen.status("no track playing")
			return

		if self.interactive_seek is None:
			self.interactive_seek = time_now

		self.interactive_seek += interactive_dir * 5
		if self.interactive_seek < 0:
			self.interactive_seek = 0
		elif self.interactive_seek > time_fin:
			self.interactive_seek = time_fin

	def seek_confirm(self):
		self.mpd.seek(self.interactive_seek)
		self.screen.status("seeked to %s" % format_time(self.interactive_seek))
		self.interactive_seek = None

	def seek_prompt(self):
		spos = self.screen.prompt('seek to: ', format='[+/-] [[hr:]min:]sec')
		if spos == None:
			return

		relative = ''
		if spos.startswith('+') or spos.startswith('-'):
			relative = spos[0]
			spos = spos[1:]

		segments = spos.split(':')
		if len(segments) > 3:
			self.screen.status("too many separators in time")
			return

		while len(segments) < 3:
			segments.insert(0, 0)
		try:
			time = int(segments[2]) + int(segments[1]) * 60 + int(segments[0]) * 24 * 60
		except ValueError:
			self.screen.status("invalid number")
			return

		if relative:
			time_now, _ = self.get_mpd_times()
			time = time_now + time * int(relative + "1")

		if time < 0:
			time = 0
		self.mpd.seek(time)

	def confirm(self):
		if self.interactive_seek is not None:
			self.seek_confirm()
		else:
			self.mpd.play(self.draw_selected)

	def escape(self):
		if self.interactive_seek is not None:
			self.interactive_seek = None
			self.screen.status("cancelled seek")

	def playlist_load(self):
		playlists = sorted(self.mpd.get_playlists())

		self.screen.clear()
		self.screen.scroll_output(3, 0, playlists)

		name = self.screen.prompt('playlist: ', autocomplete=playlists)
		if name is None:
			return
		self.mpd.playlist_append_track(name)

	def playlist_clear(self):
		self.mpd.playlist_clear()

	def playlist_remove_current(self):
		if len(self.selection) > 0:
			ids = self.selection.keys()
			to_remove = filter(lambda entry: entry['Id'] in ids, self.mpd.playlist)
			for track in sorted(to_remove, lambda a, b: b['Pos'] - a['Pos']):
				self.mpd.remove(track['Pos'])
		else:
			pos = self.mpd.playlist[self.draw_selected]['Pos']
			self.mpd.remove(pos)

	def password(self):
		pw = self.screen.prompt('password: ', pw=True)
		if pw == None or len(pw) == 0:
			return
		self.mpd.attempt_password(pw)
		self.screen.status('password accepted')

	def info(self, current):
		h, w = self.screen.get_max_yx()

		x = 1
		y = h / 2 - h / 4

		self.screen.window(
				x - 1, y - 1, w, h / 2,
				curses.A_BOLD | curses.color_pair(curses.COLOR_MAGENTA))

		attr = [ 'file', 'Title', 'Artist', 'Album', 'Time', 'Track', 'Genre', 'Pos', 'Id' ]

		x += 1
		i = 1
		for a in attr:
			val = try_key(current, a)
			if not val:
				continue
			if a == 'Time':
				val = format_time(val)

			s = "%s: %s" % (a, val)
			self.screen.addstr(y + i, x, s[:w - 4])
			i += 1

		self.screen.addstr(y + len(attr) + 1, x, 'Any key to continue...')
		self.screen.getchar(0)

	def view_scroll(self, inc):
		scroll_off = self.screen.calc_scrolloff(SCROLL_OFF)

		if inc > 0:
			max = self.view_max()-1

			if self.draw_top + scroll_off >= max:
				return

			self.draw_top += 1
			y = self.draw_top + scroll_off;
			if y >= self.draw_selected:
				self.draw_selected = y
				if self.draw_selected > max:
					self.draw_selected = max
		else:
			if self.draw_top == 0:
				return
			self.draw_top -= 1
			y = self.draw_top + self.screen.get_max_y() - 2 - scroll_off
			if y < self.draw_selected:
				self.draw_selected = y

	def shellout(self):
		cmd = self.screen.prompt('!', allow_empty=True)
		if cmd is None:
			return
		if cmd == '':
			cmd = os.environ["SHELL"] or "sh"
		self.screen.hide()
		os.system(cmd)
		sys.stdout.write("(press RETURN)")
		while self.screen.getchar(0) != ord('\n'):
			pass


def main(args):
	if len(args) != 1:
		print >>sys.stderr, "Usage: %s" % args[0]
		sys.exit(2)

	screen = Screen()

	printme = None
	lastexception = None

	try:
		screen.status('Connecting...', update=True)
		mpd = create_mpd(screen)

		mpcpy = Mpcpy(mpd, screen)

		mpcpy.view_current()
		mpcpy.run()
	except MPDException as e:
		printme = "MPDException: %s" % e
	except KeyboardInterrupt as e:
		printme = "interrupted!"
	except Exception as e:
		lastexception = e

	try:
		screen.teardown()
	except Exception:
		pass

	if printme:
		print >>sys.stderr, printme
		sys.exit(1)
	elif lastexception:
		print >>sys.stderr, "caught error during mpcpy execution:"
		import traceback
		traceback.print_exc(lastexception)

main(sys.argv)
