#!/usr/bin/python2

import curses
import socket
import sys, errno, os
import re
import time
import string

# const
SCROLL_OFF     = 5
CURSES_TIMEOUT = 250
SLEEP_TIME     = 1

# timing
laststatus = 0

#  ncurses
stdscr = None
draw_selected = 0
draw_top = 0
draw_playing = -1

#  socket
sock = -1

# memory
mpd_statusdict = {}
mpd_playlist   = []
mpd_current    = {}
mpd_xfade      = 5

mpd_host       = ''
mpd_port       = 0

search_regex   = None
search_str     = ''
search_rev     = 1

def dump_list(pre, l):
	for i in l:
		sys.stderr.write("%s: %s\n" % (pre, i))

def dump_map(pre, m):
	for k in m.keys():
		sys.stderr.write("%s: %s => %s\n" % (pre, k, m[k]))

# ----------------------------------------------------
# socket/mpd code

class mpcpyException(Exception):
	def __init__(self, e):
		self.e = e
	def __str__(self):
		return self.e

class MPDException(Exception):
	def __init__(self, e):
		self.e = e
	def __str__(self):
		return self.e

def confirm():
	global stdscr

	ch = getchar(0)

	if ch == ord('\n') or ch == ord('y'):
		return True
	return False

def mpd_connect():
	global sock, mpd_host, mpd_port
	import os

	sock = socket.socket()
	pw = ''

	host = os.getenv('MPD_HOST', 'localhost')
	port = os.getenv('MPD_PORT', '6600')

	if host.find("@") != -1:
		parts = host.split("@")
		pw = parts[0]
		host = ''.join(parts[1:])


	try:
		port = int(port)
		mpd_host, mpd_port = host, port
		sock.connect((host, port))
	except Exception as e:
		raise MPDException("Couldn't connect to mpd: %s" % e)
	except ValueError as e:
		raise MPDException("Couldn't parse port (%s): %s" % (port, e))

	s    = sock.recv(512)
	data = s.split()

	if len(data) != 3 or not (data[0] == 'OK' and data[1] == 'MPD'):
		raise MPDException("Invalid string from mpd: %s" % s)

	vers = data[2].split('.')
	if len(vers) != 3:
		raise MPDException("Invalid version string from mpd: %s" % data[2])

	try:
		if int(vers[0]) != 0 or int(vers[1]) != 16: # or int(vers[2]) != 0:
			global stdscr

			stdscr.addstr("MPD (%s:%d) version: %s, continue? (Y/n) " %
					(host, port, data[2]))

			if not confirm():
				raise MPDException("Invalid MPD version: %s (reply: %d)" % (data[2], ch))
	except TypeError as e:
		raise MPDException("Invalid version string from mpd: %s" % data[2])

	if len(pw):
		mpd_cmd('password "%s"' % pw)
	# good to go, end of function


def mpd_close():
	global sock
	sock.close()


def mpd_cmd(cmd):
	"""Send 'cmd' to mpd, and read lines until we get an 'OK'"""
	global sock
	sock.send(cmd + '\n')

	lines = []
	saved = ''
	while True:
		got = sock.recv(4096, socket.MSG_PEEK)

		lastnl = got.rfind('\n')
		if lastnl == -1:
			# FIXME: check for got.len eq 4096
			time.sleep(0.2)
			continue

		got = filter(len, sock.recv(lastnl).split('\n'))

		if len(got):
			lines.extend(got)

			last = lines[len(lines)-1]
			if last == 'OK':
				ret = lines[:len(lines)-2] # all but "OK"
				return ret
			elif last[:3] == 'ACK':
				raise MPDException("MPD error: %s (from \"%s\")" % (last, cmd))

def list_to_map(lst):
	curmap = {}
	i = 0
	while i < len(lst):
		pos = lst[i].find(':')
		if pos == -1:
			raise Exception("list_to_map: no colon in line: \"%s\"" % lst[i])

		curmap[lst[i][:pos]] = lst[i][pos+2:]
		i += 1
	return curmap


def mpd_status():
	global mpd_current, mpd_statusdict
	mpd_current    = list_to_map(mpd_cmd("currentsong"))
	mpd_statusdict = list_to_map(mpd_cmd("status"))

	# FIXME: check for vitals and throwdown if not found
	for k in ['random', 'repeat', 'consume', 'xfade', 'single']:
		mpd_statusdict[k] = int(mpd_statusdict[k])

	if 'Pos' in mpd_current.keys():
		mpd_current['Pos'] = int(mpd_current['Pos'])
	else:
		mpd_current['Pos'] = 0


def mpd_getplaylist():
	data = mpd_cmd("playlistinfo")

	mpd_playlist = []
	i = 0
	while i < len(data):
		curmap = {}
		while i < len(data):
			pos = data[i].find(':')
			if pos == -1:
				raise MPDException("mpd_getplaylist: no colon in line: \"%s\"" % data[i])

			key = data[i][:pos]
			if key == 'file' and 'file' in curmap.keys():
				# already have, move on
				break
			curmap[key] = data[i][pos+2:]
			i += 1
		mpd_playlist.append(curmap)

	return mpd_playlist # [ { 'file' : 'tim.mp3', 'Id' : 5 }, { 'file' : 'bob.mp3', 'Id' : 3 } ]


def mpd_noreply(cmd):
	ret = mpd_cmd(cmd)
	if len(ret) != 0:
		raise MPDException("Invalid MPD reply: %s" % ret[0])

def mpd_time(s):
	n = int(s)
	secs  = n % 60
	mins  = n / 60
	hr    = mins / 60
	mins %= 60

	if hr:
		return "%02d:%02d:%02d" % (hr, mins, secs)
	return "%02d:%02d" % (mins, secs)


def mpd_play(i = -1): mpd_noreply("play %d" % i) if i != -1 else mpd_noreply("play")
def mpd_pause():      mpd_noreply("pause")
def mpd_stop():       mpd_noreply("stop")
def mpd_prev():       mpd_noreply("previous")
def mpd_next():       mpd_noreply("next")
def mpd_stop():       mpd_noreply("stop")

def mpd_seek(pos):
	global mpd_current
	mpd_noreply("seek %d %d" % (mpd_current['Pos'], pos))

def mpd_toggle():     global mpd_statusdict; mpd_pause() if mpd_statusdict['state'] == 'play' else mpd_play()
def mpd_remove():     global draw_selected;  mpd_noreply("delete %d"    % draw_selected)

def mpd_random():     global mpd_statusdict; mpd_noreply("random %d"    % (1-mpd_statusdict['random']))
def mpd_repeat():     global mpd_statusdict; mpd_noreply("repeat %d"    % (1-mpd_statusdict['repeat']))
def mpd_consume():    global mpd_statusdict; mpd_noreply("consume %d"   % (1-mpd_statusdict['consume']))
def mpd_single():     global mpd_statusdict; mpd_noreply("single %d"    % (1-mpd_statusdict['single']))

def mpd_crossfade():
	global mpd_statusdict, mpd_xfade
	if mpd_statusdict['xfade'] == 0:
		mpd_noreply("crossfade %d" % mpd_xfade)
	else:
		mpd_noreply("crossfade 0")

def mpd_setvol(v):    mpd_noreply("setvol %d" % v)
def mpd_volume(v):    mpd_noreply("volume %d" % v)

# ----------------------------------------------------
# ncurses code

def draw():
	global stdscr, mpd_playlist, mpd_statusdict, mpd_current
	global draw_top, draw_selected

	if 'state' in mpd_statusdict.keys():
		state = mpd_statusdict['state']
	else:
		state = '<no state>'

	if 'Title' in mpd_current.keys():
		current_song = mpd_current['Title']
	elif 'file' in mpd_current.keys():
		current_song = mpd_current['file']
	else:
		current_song = "<unknown>"

	time_now = 0
	time_fin = 0
	if 'time' in mpd_statusdict.keys():
		song_time = mpd_statusdict['time']
		times = song_time.split(':')
		time_now = times[0]
		time_fin = times[1]

	stdscr.move(0, 0)
	stdscr.clrtoeol()

	stdscr.addstr("[%s%s%s%s%s] showing %d/%d, %s: %s %s/%s" % (
		'r' if mpd_statusdict['repeat' ] > 0 else '-',
		'z' if mpd_statusdict['random' ] > 0 else '-',
		'y' if mpd_statusdict['single' ] > 0 else '-',
		'x' if mpd_statusdict['xfade'  ] > 0 else '-',
		'c' if mpd_statusdict['consume'] > 0 else '-',
		draw_selected + 1, len(mpd_playlist),
		state, current_song, mpd_time(time_now), mpd_time(time_fin)))

	maxen = stdscr.getmaxyx()
	maxy  = maxen[0]
	maxx  = maxen[1]

	i = draw_top
	for y in range(2, maxy):
		if i >= len(mpd_playlist):
			break

		stdscr.move(y, 0)
		stdscr.clrtoeol()

		if i == draw_selected:
			if i == mpd_current['Pos']:
				# selected _and_ playing
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_YELLOW)
			else:
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_RED)
		elif i == mpd_current['Pos']:
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)
			# Black
			# Blue
			# Green
			# Red
			# White
			# Yellow
		else:
			attr = curses.A_NORMAL


		time   = mpd_playlist[i]['Time'  ] if  'Time'   in mpd_playlist[i].keys() else '0'
		artist = mpd_playlist[i]['Artist'] if  'Artist' in mpd_playlist[i].keys() else ''
		title  = mpd_playlist[i]['Title' ] if  'Title'  in mpd_playlist[i].keys() else ''
		album  = mpd_playlist[i]['Album' ] if  'Album'  in mpd_playlist[i].keys() else ''

		# FIXME: don't clip fields until their width is calculated
		time   = mpd_time(time)[:8]
		artist = artist[:20]
		title  = title[ :35]
		album  = album[ :20]

		scale = float(maxx) / float(8+20+30+20)
		try:
			stdscr.addstr("%-*s %-*s %-*s %-*s" % (
				int( 8 * scale), time,
				int(20 * scale), artist,
				int(30 * scale), title,
				int(20 * scale), album
				), attr)
		except Exception:
			pass

		i += 1
		if i == len(mpd_playlist):
			break

	for y in range(y + 1, maxy):
		stdscr.move(y, 0)
		stdscr.clrtoeol()
	stdscr.move(0, 0)


def status(s):
	stdscr.move(1, 0)
	stdscr.clrtoeol()
	stdscr.addstr(s)

def view_inc(n):
	global draw_selected, draw_top
	global stdscr, mpd_playlist

	if draw_selected < len(mpd_playlist)-1:
		draw_selected += n
		if draw_selected >= len(mpd_playlist): draw_selected = len(mpd_playlist)-1

		maxy = stdscr.getmaxyx()[0] - 2

		# increase draw_top if we can't see draw_selected, but
		# don't inc draw_top if draw_top + maxy < len(mpd_playlist)
		if draw_selected - draw_top > maxy - SCROLL_OFF and \
				draw_top + maxy < len(mpd_playlist):
			draw_top = draw_selected - maxy + SCROLL_OFF

def view_dec(n):
	global draw_selected, draw_top

	if draw_selected > 0:
		draw_selected -= n
		if draw_selected < 0: draw_selected = 0

		if draw_selected - draw_top < SCROLL_OFF:
			draw_top = draw_selected - SCROLL_OFF
			if draw_top < 0:
				draw_top = 0


def view_set(n):
	global draw_selected, draw_top, stdscr, mpd_playlist

	maxy = stdscr.getmaxyx()[0] - 2

	if n < 0:
		n = 0
	elif n >= len(mpd_playlist):
		n = len(mpd_playlist) - 1

	draw_selected = n
	draw_top = draw_selected - maxy / 2

	if draw_top > len(mpd_playlist) - maxy:
		draw_top = len(mpd_playlist) - maxy
	if draw_top < 0:
		draw_top = 0

def view_current():
	global mpd_current
	view_set(mpd_current['Pos'])

def getstr():
	global stdscr

	stdscr.timeout(-1)

	y, x = stdscr.getyx()

	ret = ''
	while True:
		c = stdscr.getch()

		try:
			chrd = chr(c)
		except:
			chrd = ''

		if c == ord('\n'):
			break

		elif c == 033:
			ret = ''
			break

		elif c == 127 or c == 263 or c == ord('\b'):
			if len(ret):
				ret = ret[:len(ret)-1]
			else:
				ret = ''
				break # escape

		elif c == 259:
			# up
			# TODO: history
			pass
		elif c == 258:
			# down
			# TODO: history
			pass

		elif chrd in string.printable:
			ret += chrd

		stdscr.move(y, x)
		stdscr.addstr(ret)
		stdscr.refresh()

	stdscr.timeout(CURSES_TIMEOUT)
	return ret if len(ret) else None

def getsearch(reverse):
	global stdscr, search_regex, search_str

	status('?' if reverse else '/')

	search_str = getstr()
	if search_str is None:
		return False

	search_regex = re.compile(".*" + search_str + ".*", re.IGNORECASE)
	return True


def dosearch(reverse):
	global stdscr, mpd_playlist, draw_selected, search_regex, search_str

	if reverse:
		l = range(draw_selected - 1, 0, -1)
		l.extend(i for i in range(len(mpd_playlist) - 1, draw_selected - 1, -1))
	else:
		l = range(draw_selected + 1, len(mpd_playlist))  # start seaching at current + 1
		l.extend(i for i in range(0, draw_selected + 1)) # include draw_selected in range


	def search_descript(item, items):
		words = []
		for i in items:
			try:
				words.append([item[i], i])
			except:
				pass
		return words

	if search_regex is None:
		if getsearch(reverse) == False:
			return

	for trax in [mpd_playlist[i] for i in l]:
		words = search_descript(trax, ['Title', 'Artist', 'Album'])
		# returns: [ [ '<title>', 'Title'], [ '<artist>', 'Artist' ] ]

		for w in words:
			if search_regex.match(w[0]):
				view_set(int(trax['Pos']))
				status("Found in %s" % w[1])
				return
	status("Couldn't find %s" % search_str)


def seek():
	status('seek to: ')
	spos = getstr()
	try:
		if spos.find(':'):
			segments = spos.split(':')
			if len(segments) > 3:
				status("that's not a time... come on")
				return
			while len(segments) < 3:
				segments.insert(0, 0)
			pos = int(segments[2]) + int(segments[1]) * 60 + int(segments[0]) * 24 * 60
		else:
			pos = int(spos)
	except:
		status('invalid position... numerical/time format, you derp')
		return

	mpd_seek(pos) # outside the try:, so mpd errors are thrown back

def getchar(timeout = 1):

	if timeout:
		stdscr.timeout(CURSES_TIMEOUT) # after 100ms, -1 is returned
	else:
		stdscr.timeout(-1)

	ch = stdscr.getch() # main sleep statement here

	ret = None if ch == -1 else ch

	if not timeout:
		stdscr.timeout(CURSES_TIMEOUT)

	return ret

def info(current):
	global stdscr
	yx = stdscr.getmaxyx()
	h = yx[0]
	w = yx[1]

	x = 1
	y = h / 2 - h / 4

	def window(start_x, start_y, w, h, attr = 0):
		end_x, end_y = start_x + w - 1, start_y + h - 1

		for x in range(start_x, start_x + w):
			for y in range(start_y, start_y + h):
				c = ' '
				if x in (start_x, end_x):
					if y in (start_y, end_y):
						c = '+'
					else:
						c = '|'
				elif y in (start_y, end_y):
					c = '-'
				stdscr.addch(y, x, c, attr)

	window(x - 1, y - 1, w - 1, h/2,
			curses.A_BOLD | curses.color_pair(curses.COLOR_MAGENTA))

	attr = [ 'file', 'Title', 'Artist', 'Album', 'Time', 'Track', 'Genre' ]

	i = 0
	for a in range(0, len(attr)):
		try:
			s = attr[a] + ': ' + current[attr[a]]
			stdscr.addstr(y + i, x, s[:w - 4])
			i += 1
		except:
			pass

	stdscr.addstr(y + len(attr) + 1, x, 'Any key to continue...')
	getchar(0)


def keys():
	global draw_selected, draw_top, stdscr, search_rev
	global mpd_current, mpd_playlist

	def ctrl_and(n):
		return ord(n) - ord('a') + 1

	def clip_draw_selected():
		global draw_selected, mpd_playlist
		if draw_selected >= len(mpd_playlist):
			draw_selected = len(mpd_playlist) - 1
		if draw_selected < 0:
			draw_selected = 0

	maxy = stdscr.getmaxyx()[0]

	ch = getchar()
	if ch is None:
		return True

	need_mpd_refresh = False

	if False: pass # lolol
	elif ch == ord('q'):      return False
	elif ch == ord('j'):      view_inc(1)
	elif ch == ord('k'):      view_dec(1)
	elif ch == ctrl_and('d'): view_set(draw_selected + maxy / 2)
	elif ch == ctrl_and('u'): view_set(draw_selected - maxy / 2)
	elif ch == ctrl_and('f'): view_set(draw_selected + maxy)
	elif ch == ctrl_and('b'): view_set(draw_selected - maxy)
	elif ch == ord('g'):
		ch = getchar(0)

		if ch == ord('g'):
			view_set(0)
		elif ch == ord('s'):
			seek()
		else:
			status("unknown g-key %d - 'g' for top, 's' for seek" % ch)

	elif ch == ord('i'):
		info(mpd_current)

	elif ch == ord('G'):      view_set(len(mpd_playlist) - 1)

	elif ch == ord('H'):
		draw_selected = draw_top + SCROLL_OFF
		clip_draw_selected()
	elif ch == ord('L'):
		draw_selected = draw_top + maxy - SCROLL_OFF - 2 # 2 for the status bars
		clip_draw_selected()
	elif ch == ord('M'):
		draw_selected = draw_top + maxy / 2
		clip_draw_selected()

	elif ch == ord('d'):  need_mpd_refresh = True; mpd_remove()
	elif ch == ord('p'):  need_mpd_refresh = True; mpd_toggle()
	elif ch == ord('s'):  need_mpd_refresh = True; mpd_stop()
	elif ch == ord('\n'): need_mpd_refresh = True; mpd_play(draw_selected)

	elif ch == ord('>'):  need_mpd_refresh = True; mpd_next()
	elif ch == ord('<'):  need_mpd_refresh = True; mpd_prev()

	elif ch == ord('r') or ch == ord('1'):  need_mpd_refresh = True; mpd_repeat()
	elif ch == ord('z') or ch == ord('2'):  need_mpd_refresh = True; mpd_random()
	elif ch == ord('y') or ch == ord('3'):  need_mpd_refresh = True; mpd_single()
	elif ch == ord('x') or ch == ord('4'):  need_mpd_refresh = True; mpd_crossfade() # FIXME: prompt
	elif ch == ord('c') or ch == ord('5'):  need_mpd_refresh = True; mpd_consume()

	elif ch == ord('/') or ch == ord('?') or ch == ord('n') or ch == ord('N'):
		go = True

		if ch == ord('/') or ch == ord('?'):
			search_rev = 0 if ch == ord('/') else 1
			go = getsearch(search_rev)

		if go:
			order_adj = search_rev
			if ch == ord('N'):
				order_adj = 1 if order_adj == 0 else 0
			dosearch(order_adj)

	elif ch == ord('o'):  view_current()

	elif ch == 410: status('')

	else: status("unknown key %d" % ch)

	if need_mpd_refresh:
		global laststatus
		laststatus = 0

	return True


# ----------------------------------------------------
# general code


def run():
	global stdscr, laststatus, mpd_host, mpd_port

	status("connected to mpd @ %s:%d" % (mpd_host, mpd_port))

	# TODO: check for playlist changes
	# TODO: ability to alter playlist

	while True:
		draw()
		stdscr.move(0, 0)
		if not keys():
			break

		if laststatus + SLEEP_TIME < time.time():
			# two seconds
			# FIXME: use mpd_cmd("raw")
			laststatus = time.time()
			mpd_status()
	mpd_close()


if len(sys.argv) > 1:
	cmd = "mpc "
	for arg in sys.argv[1:]:
		cmd += "%s " % arg
	sys.exit(os.system(cmd))

try:
	stdscr = curses.initscr()

	curses.start_color()
	curses.use_default_colors()
	curses.init_pair(curses.COLOR_BLACK,   -1,                   -1)
	curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN,   -1)
	curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE,   -1)
	curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED,     -1)
	curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN,    -1)
	curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1)
	curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE,    -1)
	curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW,  -1)

	curses.cbreak()
	curses.noecho()
	stdscr.keypad(1)
except Exception as e:
	print "Couldn't start ncurses: %s" % e
	sys.exit(1)

printme = ''
try:
	mpd_connect()
	mpd_playlist = mpd_getplaylist()

	mpd_status()

	view_current()

	run()
except MPDException as e:
	printme = "MPDException: %s" % e
except KeyboardInterrupt as e:
	printme = "interrupted!"
except curses.error:
	printme = "mpcpy needs more columns on the terminal"


try:
	curses.nocbreak()
	curses.echo()
	curses.endwin()
except Exception:
	pass

if len(printme):
	print >>sys.stderr, printme
