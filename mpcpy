#!/usr/bin/python2

import curses
import socket
import sys, errno, os
import re
import time
import string
import select

# TODO:  ability to change the playlist - add+remove songs/select playlist
#        output control
#        get the time working again... duh
# FIXME: optimise playlist dragging at startup

# const
SCROLL_OFF     = 5
CURSES_TIMEOUT = 250
SLEEP_TIME     = 1
TRACING        = 0

# relative differences
SPACE_TIME     = 2
SPACE_ARTIST   = 5
SPACE_TITLE    = 8
SPACE_ALBUM    = 4

#  ncurses
stdscr = None
draw_selected = 0
draw_top = 0
draw_playing = -1

#  socket
sock = -1

# memory
mpd_statusdict = {}
mpd_playlist   = []
mpd_current    = {}
mpd_xfade      = 5

mpd_host       = ''
mpd_port       = 0

search_regex   = None
search_str     = ''
search_rev     = 1

marks          = {}

def dump_list(pre, l):
	for i in l:
		sys.stderr.write("%s: %s\n" % (pre, i))

def dump_map(pre, m):
	for k in m.keys():
		sys.stderr.write("%s: %s => %s\n" % (pre, k, m[k]))

def trace(s):
	global TRACING
	if TRACING:
		print >>sys.stderr, "%d: %s" % (time.time(), s)

# ----------------------------------------------------
# socket/mpd code

class mpcpyException(Exception):
	pass
class MPDException(Exception):
	pass

def confirm():
	global stdscr

	ch = getchar(0)

	if ch == ord('\n') or ch == ord('y'):
		return True
	return False

def hoststr():
	global mpd_host, mpd_port
	return "%s:%s" % (mpd_host, mpd_port)

def mpd_connect():
	global sock, mpd_host, mpd_port
	import os

	sock = socket.socket()
	pw = ''

	host = os.getenv('MPD_HOST', 'localhost')
	port = os.getenv('MPD_PORT', '6600')

	if host.find("@") != -1:
		parts = host.split("@")
		pw = parts[0]
		host = ''.join(parts[1:])

	try:
		port = int(port)
		mpd_host, mpd_port = host, port
		sock.connect((host, port))
	except Exception as e:
		raise MPDException("Couldn't connect to mpd @ %s - %s" % (hoststr(), e))
	except ValueError as e:
		raise MPDException("Couldn't parse port (%s): %s" % (port, e))

	s    = sock.recv(512)
	data = s.split()

	if len(data) != 3 or not (data[0] == 'OK' and data[1] == 'MPD'):
		raise MPDException("Invalid string from mpd: %s" % s)

	vers = data[2].split('.')
	if len(vers) != 3:
		raise MPDException("Invalid version string from mpd: %s" % data[2])

	try:
		if int(vers[0]) != 0 or int(vers[1]) != 16: # or int(vers[2]) != 0:
			global stdscr

			stdscr.addstr("MPD (%s) version: %s, continue? (Y/n) " %
					(hoststr(), data[2]))

			if not confirm():
				raise MPDException("Invalid MPD version: %s (reply: %d)" % (data[2], ch))
	except TypeError as e:
		raise MPDException("Invalid version string from mpd: %s" % data[2])

	if len(pw):
		mpd_password(pw)
	# good to go, end of function


def mpd_close():
	global sock
	sock.close()

def mpd_raw(cmd):
	global sock
	trace('sock.send("%s\\n")' % cmd)
	sock.send(cmd + '\n')

def mpd_readlines(prevcmd):
	lines = []
	saved = ''
	while True:
		got = sock.recv(4096, socket.MSG_PEEK)

		lastnl = got.rfind('\n')
		if lastnl == -1:
			if len(got) == 4096:
				raise MPDException('No newline found in server message')
			time.sleep(0.5)
			continue

		got = filter(len, sock.recv(lastnl + 1).split('\n'))

		if len(got):
			lines.extend(got)

			last = lines[len(lines)-1]
			if last == 'OK':
				ret = lines[:len(lines)-1] # all but "OK"
				return ret
			elif last[:3] == 'ACK':
				if prevcmd.find('password') == 0:
					extra = ''
				else:
					extra = ' (from "%s")' % prevcmd
				raise MPDException("MPD error: %s%s" % (last, extra))

def mpd_cmd(cmd):
	"""Send 'cmd' to mpd, and read lines until we get an 'OK'"""
	mpd_raw(cmd)
	return mpd_readlines(cmd)

def list_to_map(lst):
	curmap = {}
	i = 0
	while i < len(lst):
		pos = lst[i].find(':')
		if pos == -1:
			raise Exception("list_to_map: no colon in line: \"%s\"" % lst[i])

		curmap[lst[i][:pos]] = lst[i][pos+2:]
		i += 1
	return curmap


def mpd_getstate():
	global mpd_statusdict
	mpd_statusdict = list_to_map(mpd_cmd("status"))
	if 'state' not in mpd_statusdict.keys():
		mpd_statusdict['state'] = 'stop'
	for k in ['random', 'repeat', 'consume', 'xfade', 'single']:
		mpd_statusdict[k] = int(mpd_statusdict[k])

def mpd_getplaying():
	global mpd_current
	mpd_current = list_to_map(mpd_cmd("currentsong"))
	if 'Pos' in mpd_current.keys():
		mpd_current['Pos'] = int(mpd_current['Pos'])
	else:
		mpd_current['Pos'] = 0

def mpd_parseplaylist(data):
	ret = []
	i = 0
	while i < len(data):
		curmap = {}
		while i < len(data):
			pos = data[i].find(':')
			if pos == -1:
				raise MPDException("mpd_parseplaylist: no colon in line: \"%s\"" % data[i])

			key = data[i][:pos]
			if key == 'file' and 'file' in curmap.keys():
				# already have, move on
				break
			curmap[key] = data[i][pos+2:]
			i += 1
		ret.append(curmap)
	return ret

def mpd_getplaylist():
	data = mpd_cmd("playlistinfo")

	return mpd_parseplaylist(data) # [ { 'file' : 'tim.mp3', 'Id' : 5 }, { 'file' : 'bob.mp3', 'Id' : 3 } ]


def mpd_updateplaylist():
	global mpd_statusdict, mpd_playlist

	oldpl = mpd_statusdict['playlist'] # id
	changes = mpd_cmd('plchanges %s' % oldpl)
	mpd_getstate()
	newlen = mpd_statusdict['playlistlength']

	changes = mpd_parseplaylist(changes)

	for track in changes:
		for i in range(0, len(mpd_playlist)):
			if mpd_playlist[i]['Id'] == track['Id']:
				mpd_playlist[i] = track
				mpd_playlist[i]['Pos'] = int(mpd_playlist[i]['Pos'])
				break

	mpd_playlist = sorted(mpd_playlist, key = lambda tr: int(tr['Pos']))


def mpd_noreply(cmd):
	ret = mpd_cmd(cmd)
	if len(ret) != 0:
		extra = ''
		if cmd.find('password') == -1:
			extra = " (from %s)" % cmd
		raise MPDException("Invalid MPD reply: %s%s" % (ret[0], extra))

def mpd_time(s):
	n = int(s)
	secs  = n % 60
	mins  = n / 60
	hr    = mins / 60
	mins %= 60

	if hr:
		return "%02d:%02d:%02d" % (hr, mins, secs)
	return "%02d:%02d" % (mins, secs)


def mpd_play(i = -1): mpd_noreply("play %d" % i) if i != -1 else mpd_noreply("play")
def mpd_pause():      mpd_noreply("pause")
def mpd_stop():       mpd_noreply("stop")
def mpd_prev():       mpd_noreply("previous")
def mpd_next():       mpd_noreply("next")
def mpd_stop():       mpd_noreply("stop")

def mpd_seek(pos):
	global mpd_current
	mpd_noreply("seek %d %d" % (mpd_current['Pos'], pos))

def mpd_toggle():     global mpd_statusdict; mpd_pause() if mpd_statusdict['state'] == 'play' else mpd_play()
def mpd_remove(n):    global draw_selected;  mpd_noreply("delete %d"    % n)

def mpd_random():     global mpd_statusdict; mpd_noreply("random %d"    % (1-mpd_statusdict['random']))
def mpd_repeat():     global mpd_statusdict; mpd_noreply("repeat %d"    % (1-mpd_statusdict['repeat']))
def mpd_consume():    global mpd_statusdict; mpd_noreply("consume %d"   % (1-mpd_statusdict['consume']))
def mpd_single():     global mpd_statusdict; mpd_noreply("single %d"    % (1-mpd_statusdict['single']))
def mpd_password(pw): mpd_noreply('password "%s"' % pw)
def mpd_move(a, b):   mpd_noreply('move "%s" "%s"' % (a, b))

def mpd_crossfade(n = -1):
	global mpd_statusdict, mpd_xfade

	if n == -1:
		if mpd_statusdict['xfade'] == 0:
			mpd_noreply("crossfade %d" % mpd_xfade)
		else:
			mpd_noreply("crossfade 0")
	else:
		mpd_xfade = n
		mpd_noreply("crossfade %d" % mpd_xfade)

def mpd_setvol(v):    mpd_noreply("setvol %d" % v)
def mpd_volume(v):    mpd_noreply("volume %d" % v)

def mpd_idle(b):
	if b:
		mpd_raw('idle')
	else:
		try:
			mpd_noreply('noidle')
		except:
			pass

def mpd_playlists_get():
	return map(lambda line: line[10:], filter(lambda line: line[:10] == 'playlist: ', mpd_cmd('lsinfo')))

def mpd_playlist_append(name):
	mpd_noreply('load "%s"' % name)

def mpd_playlist_clear():
	mpd_noreply('clear')

def mpd_playlist_save(name):
	mpd_noreply('save "%s"' % name)

def mpd_playlist_del(name):
	mpd_noreply('rm "%s"' % name)

def playlist_save():
	global stdscr
	name = prompt('save playlist as: ')
	if name is None:
		return

	try:
		mpd_playlist_save(name)
		status('saved as %s' % name)
	except MPDException as e:
		status('playlist "%s" exists, overwrite? (y/n): ' % name)
		if confirm():
			mpd_playlist_del(name)
			mpd_playlist_save(name)
			status('overwrote playlist %s' % name)
		else:
			status('playlist unsaved')

def playlist_load():
	global stdscr

	stdscr.clear()
	scroll_output(3, 0, mpd_playlists_get())

	name = prompt('playlist: ')
	if name is None:
		return

	mpd_playlist_append(name)
	global mpd_playlist
	mpd_playlist = mpd_getplaylist()

def playlist_clear():
	global mpd_playlist
	mpd_playlist_clear()
	mpd_playlist[:] = []

def playlist_remove_current():
	global draw_selected
	mpd_remove(draw_selected)
	global mpd_playlist
	mpd_playlist = mpd_getplaylist()

# ----------------------------------------------------
# ncurses code

def draw():
	global stdscr, mpd_playlist, mpd_statusdict, mpd_current
	global draw_top, draw_selected

	def statusstr():
		return "[%s%s%s%s%s]" % (
				'r' if mpd_statusdict['repeat' ] > 0 else '-',
				'z' if mpd_statusdict['random' ] > 0 else '-',
				'y' if mpd_statusdict['single' ] > 0 else '-',
				'x' if mpd_statusdict['xfade'  ] > 0 else '-',
				'c' if mpd_statusdict['consume'] > 0 else '-')


	if 'Title' in mpd_current.keys():
		current_song = mpd_current['Title']
	elif 'file' in mpd_current.keys():
		current_song = mpd_current['file']
	else:
		current_song = "<unknown>"

	time_now = 0
	time_fin = 0
	if 'time' in mpd_statusdict.keys():
		song_time = mpd_statusdict['time']
		times = song_time.split(':')
		time_now = times[0]
		time_fin = times[1]

	stdscr.move(0, 0)
	stdscr.clrtoeol()

	stdscr.addstr("%s showing %d/%d, %s: %s %s/%s" % (
		statusstr(),
		draw_selected + 1, len(mpd_playlist),
		mpd_statusdict['state'], current_song, mpd_time(time_now), mpd_time(time_fin)))

	maxen = stdscr.getmaxyx()
	maxy  = maxen[0]
	maxx  = maxen[1]

	i = draw_top
	for y in range(2, maxy):
		if i >= len(mpd_playlist):
			break

		stdscr.move(y, 0)
		stdscr.clrtoeol()

		if i == draw_selected:
			if i == mpd_current['Pos']:
				# selected _and_ playing
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_YELLOW)
			else:
				attr = curses.A_BOLD | curses.color_pair(curses.COLOR_RED)
		elif i == mpd_current['Pos']:
			attr = curses.A_BOLD | curses.color_pair(curses.COLOR_GREEN)
			# Black
			# Blue
			# Green
			# Red
			# White
			# Yellow
		else:
			attr = curses.A_NORMAL


		time   = mpd_playlist[i]['Time'  ] if  'Time'   in mpd_playlist[i].keys() else '0'
		artist = mpd_playlist[i]['Artist'] if  'Artist' in mpd_playlist[i].keys() else ''
		title  = mpd_playlist[i]['Title' ] if  'Title'  in mpd_playlist[i].keys() else ''
		album  = mpd_playlist[i]['Album' ] if  'Album'  in mpd_playlist[i].keys() else ''

		scale = float(maxx) / float(SPACE_TIME + SPACE_ARTIST + SPACE_TITLE + SPACE_ALBUM)

		time   = mpd_time(time)[:int(SPACE_TIME   * scale)]
		artist = artist[        :int(SPACE_ARTIST * scale)]
		title  = title[         :int(SPACE_TITLE  * scale)]
		album  = album[         :int(SPACE_ALBUM  * scale)]

		try:
			stdscr.addstr("%-*s %-*s %-*s %-*s" % (
				int(SPACE_TIME   * scale), time,
				int(SPACE_ARTIST * scale), artist,
				int(SPACE_TITLE  * scale), title,
				int(SPACE_ALBUM  * scale), album
				), attr)
		except Exception:
			pass

		i += 1
		if i == len(mpd_playlist):
			break

	for y in range(y + 1, maxy):
		stdscr.move(y, 0)
		stdscr.clrtoeol()
	stdscr.move(0, 0)


def status(s):
	stdscr.move(1, 0)
	stdscr.clrtoeol()
	stdscr.addstr(s)

def set_draw_top(n):
	global draw_top
	draw_top = n
	status('')

def view_inc(n):
	global draw_selected, draw_top
	global stdscr, mpd_playlist

	if draw_selected < len(mpd_playlist)-1:
		draw_selected += n
		if draw_selected >= len(mpd_playlist): draw_selected = len(mpd_playlist)-1

		maxy = stdscr.getmaxyx()[0] - 2

		# increase draw_top if we can't see draw_selected, but
		# don't inc draw_top if draw_top + maxy < len(mpd_playlist)
		if draw_selected - draw_top > maxy - SCROLL_OFF and \
				draw_top + maxy < len(mpd_playlist):
			set_draw_top(draw_selected - maxy + SCROLL_OFF)

def view_dec(n):
	global draw_selected, draw_top

	if draw_selected > 0:
		draw_selected -= n
		if draw_selected < 0: draw_selected = 0

		if draw_selected - draw_top < SCROLL_OFF:
			set_draw_top(draw_selected - SCROLL_OFF)
			if draw_top < 0:
				set_draw_top(0)


def view_set(n):
	global draw_selected, draw_top, stdscr, mpd_playlist

	n = int(n)
	maxy = stdscr.getmaxyx()[0] - 2

	if n < 0:
		n = 0
	elif n >= len(mpd_playlist):
		n = len(mpd_playlist) - 1

	draw_selected = n
	set_draw_top(draw_selected - maxy / 2)

	if draw_top > len(mpd_playlist) - maxy:
		set_draw_top(len(mpd_playlist) - maxy)
	if draw_top < 0:
		set_draw_top(0)

def view_current():
	global mpd_current
	view_set(mpd_current['Pos'])

def prompt(str, pw = 0):
	global stdscr

	status(str)
	stdscr.move(1, len(str))

	stdscr.timeout(-1)

	y, x = stdscr.getyx()

	ret = ''
	while True:
		c = stdscr.getch()

		try:
			chrd = chr(c)
		except:
			chrd = ''

		if c == ord('\n'):
			break

		elif c == 033 or c == 31:
			ret = ''
			break

		elif c == 127 or c == 263 or c == ord('\b'):
			if len(ret):
				ret = ret[:len(ret)-1]
			else:
				ret = ''
				break

		elif chrd in string.printable:
			ret += chrd

		stdscr.move(y, x)
		stdscr.addstr(('*' * len(ret)) if pw else ret)
		stdscr.refresh()

	stdscr.timeout(CURSES_TIMEOUT)
	return ret if len(ret) else None


def getsearch(reverse):
	global stdscr, search_regex, search_str

	search_str = prompt('?' if reverse else '/')
	if search_str is None:
		return False

	search_regex = re.compile(".*" + search_str + ".*", re.IGNORECASE)
	return True


def dosearch(reverse):
	global stdscr, mpd_playlist, draw_selected, search_regex, search_str

	if reverse:
		l = range(draw_selected - 1, 0, -1)
		l.extend(i for i in range(len(mpd_playlist) - 1, draw_selected - 1, -1))
	else:
		l = range(draw_selected + 1, len(mpd_playlist))  # start seaching at current + 1
		l.extend(i for i in range(0, draw_selected + 1)) # include draw_selected in range


	def search_descript(item, items):
		words = []
		for i in items:
			try:
				words.append([item[i], i])
			except:
				pass
		return words

	if search_regex is None:
		if getsearch(reverse) == False:
			return

	for trax in [mpd_playlist[i] for i in l]:
		words = search_descript(trax, ['Title', 'Artist', 'Album'])
		# returns: [ [ '<title>', 'Title'], [ '<artist>', 'Artist' ] ]

		for w in words:
			if search_regex.match(w[0]):
				view_set(trax['Pos'])
				status("Found in %s" % w[1])
				return
	status("Couldn't find %s" % search_str)


def seek():
	spos = prompt('seek to: ')
	if spos == None:
		return
	try:
		if spos.find(':'):
			segments = spos.split(':')
			if len(segments) > 3:
				status("that's not a time... come on")
				return
			while len(segments) < 3:
				segments.insert(0, 0)
			pos = int(segments[2]) + int(segments[1]) * 60 + int(segments[0]) * 24 * 60
		else:
			pos = int(spos)
	except:
		status('invalid position... numerical/time format, you derp')
		return

	mpd_seek(pos) # outside the try:, so mpd errors are thrown back

def password():
	pw = prompt('password: ', 1)
	if pw == None:
		return
	status('password accepted')
	mpd_password(pw)


def getchar(timeout = 1):

	if timeout:
		stdscr.timeout(CURSES_TIMEOUT) # after 100ms, -1 is returned
	else:
		stdscr.timeout(-1)

	ch = stdscr.getch() # main sleep statement here

	ret = None if ch == -1 else ch

	if not timeout:
		stdscr.timeout(CURSES_TIMEOUT)

	return ret

def window(start_x, start_y, w, h, attr = 0):
	end_x, end_y = start_x + w - 1, start_y + h - 1

	for x in range(start_x, start_x + w):
		for y in range(start_y, start_y + h):
			c = ' '
			if x in (start_x, end_x):
				if y in (start_y, end_y):
					c = '+'
				else:
					c = '|'
			elif y in (start_y, end_y):
				c = '-'
			stdscr.addch(y, x, c, attr)

def info(current):
	global stdscr
	yx = stdscr.getmaxyx()
	h = yx[0]
	w = yx[1]

	x = 1
	y = h / 2 - h / 4

	window(x - 1, y - 1, w, h/2,
			curses.A_BOLD | curses.color_pair(curses.COLOR_MAGENTA))

	attr = [ 'file', 'Title', 'Artist', 'Album', 'Time', 'Track', 'Genre' ]

	i = 0
	for a in attr:
		try:
			val = current[a]
			if a == 'Time':
				val = mpd_time(val)

			s = a + ': ' + val
			stdscr.addstr(y + i, x, s[:w - 4])
			i += 1
		except:
			pass

	stdscr.addstr(y + len(attr) + 1, x, 'Any key to continue...')
	getchar(0)

def scroll_output(initial_y, x, lines):
	global stdscr
	h, w = stdscr.getmaxyx()

	h -= 1
	w -= 1

	y = initial_y
	for l in lines:
		stdscr.addstr(y, x, l[:w - 4])
		y += 1
		if y >= h:
			stdscr.addstr(y, x, 'Any key for next page...')
			getchar(0)
			stdscr.clear()
			y = initial_y

	stdscr.refresh()


def help():
	helps = {
		'q': 'quit',

		'k': 'up',
		'j': 'down',
		'^d': 'pgdn/2',
		'^u': 'pgup/2',
		'^f': 'pgdn',
		'^b': 'pgup',
		'^e': 'scroll down',
		'^y': 'scroll up',

		'gg': 'top',
		'gs': 'seek',
		'G': 'bottom',

		'H': 'jump to top of screen',
		'M': 'jump to middle of screen',
		'L': 'jump to bottom of screen',

		'o': 'view current',

		'\'X': 'goto mark X',
		'mX': 'mark X',

		'i': 'show selected info',

		'<CR>': 'play selected',
		'p': 'toggle playing',
		's': 'stop playing',
		'd': 'remove selected song',
		'Q': 'queue song to play after current',

		'>': 'next',
		'<': 'prev',

		'r | 1': 'repeat',
		'z | 2': 'random',
		'y | 3': 'single',
		'c | 5': 'consume',
		'x | 4': 'xfade',

		'X': 'set xfade',

		'w': 'move song down',
		'W': 'move song up',

		'/': 'prompt + search forward',
		'?': 'prompt + search backward',
		'n': 'search next',
		'N': 'search reverse',

		'P': 'enter mpd password',

		'h': 'show this help',
	}

	global stdscr

	stdscr.clear()
	scroll_output(0, 0, map(lambda x: "%s:\t\t%s" % (x, helps[x]), sorted(helps.keys())))
	getchar(0)
	stdscr.clear()


def view_scroll(inc):
	global draw_top, draw_selected, mpd_playlist
	global stdscr

	if inc > 0:
		max = len(mpd_playlist)-1

		if draw_top + SCROLL_OFF < max:
			draw_top += 1
			y = draw_top + SCROLL_OFF;
			if y >= draw_selected:
				draw_selected = y
				if draw_selected > max:
					draw_selected = max
	else:
		if draw_top > 0:
			draw_top -= 1
			y = draw_top + stdscr.getmaxyx()[0] - 2 - SCROLL_OFF
			if y < draw_selected:
				draw_selected = y


def mark_add(ch, pos):
	marks[ch] = pos

def mark_get(ch):
	try:
		return marks[ch]
	except:
		return -1

def lastmark():
	global draw_selected
	mark_add(ord("'"), draw_selected)

def clip_draw_selected():
	global draw_selected, mpd_playlist
	if draw_selected >= len(mpd_playlist):
		draw_selected = len(mpd_playlist) - 1
	if draw_selected < 0:
		draw_selected = 0


def keys():
	global draw_selected, draw_top, stdscr, search_rev
	global mpd_current, mpd_playlist

	def ctrl_and(n):
		return ord(n) - ord('a') + 1

	maxy = stdscr.getmaxyx()[0]

	ch = getchar()
	if ch is None:
		return True

	try:
		if False: pass # lolol
		elif ch == ord('q'):      return False
		elif ch == ord('j'):      view_inc(1)
		elif ch == ord('k'):      view_dec(1)
		elif ch == ctrl_and('d'): lastmark(); view_set(draw_selected + maxy / 2)
		elif ch == ctrl_and('u'): lastmark(); view_set(draw_selected - maxy / 2)
		elif ch == ctrl_and('f'): lastmark(); view_set(draw_selected + maxy)
		elif ch == ctrl_and('b'): lastmark(); view_set(draw_selected - maxy)
		elif ch == ctrl_and('e'): view_scroll(+1)
		elif ch == ctrl_and('y'): view_scroll(-1)

		elif ch == ord('g'):
			ch = getchar(0)

			if ch == ord('g'):
				lastmark()
				view_set(0)
			elif ch == ord('s'):
				seek()

			elif ch == ord('S'):
				playlist_save()
			elif ch == ord('L'):
				playlist_load()
			elif ch == ord('C'):
				playlist_clear()

			else:
				status("unknown g-key %d" % ch)

		elif ch == ord("'"):
			ch = getchar(0)
			pos = mark_get(ch)
			if pos == -1:
				status("unset mark")
			else:
				view_set(pos)

		elif ch == ord('m'):
			ch = getchar(0)
			mark_add(ch, draw_selected)

		elif ch == ord('i'):
			info(mpd_playlist[draw_selected])

		elif ch == ord('G'):
			lastmark()
			view_set(len(mpd_playlist) - 1)

		elif ch == ord('H'):
			lastmark()
			draw_selected = draw_top + SCROLL_OFF
			clip_draw_selected()
		elif ch == ord('L'):
			lastmark()
			draw_selected = draw_top + maxy - SCROLL_OFF - 2 # 2 for the status bars
			clip_draw_selected()
		elif ch == ord('M'):
			lastmark()
			draw_selected = draw_top + maxy / 2 - 1 # for status bar
			clip_draw_selected()

		elif ch == ord('d'):  playlist_remove_current()
		elif ch == ord('p'):  mpd_toggle()
		elif ch == ord('s'):  mpd_stop()
		elif ch == ord('\n'): mpd_play(draw_selected)

		elif ch == ord('Q'):
			go = False
			try:
				nam = mpd_playlist[draw_selected]['Title']
				go = True
			except:
				status("nothing selected")

			if go:
				try:
					if os.fork() == 0:
						sys.stdout.close()
						sys.stderr.close()
						os.close(1)
						os.close(2)
						os.execvp('mpc_queue.pl', ['-f', nam])
						sys.exit(-1)
				except:
					raise
				status("queued %s" % nam)

		elif ch == ord('>'):  mpd_next()
		elif ch == ord('<'):  mpd_prev()

		elif ch == ord('r') or ch == ord('1'):  mpd_repeat()
		elif ch == ord('z') or ch == ord('2'):  mpd_random()
		elif ch == ord('y') or ch == ord('3'):  mpd_single()
		elif ch == ord('c') or ch == ord('5'):  mpd_consume()
		elif ch == ord('x') or ch == ord('4'):  mpd_crossfade()
		elif ch == ord('X'):
			s = prompt('xfade: ')
			if s != None:
				good = False
				try:
					n = int(s)
					good = True
				except:
					status('need number for xfade')

				if good:
					mpd_crossfade(n)
					status('xfade set to %d' % mpd_xfade)

		elif ch == ord('w') or ch == ord('W'):
			# shift song up or down one
			up = ch == ord('W')

			if (draw_selected > 0                   if     up else True) and \
				 (draw_selected < len(mpd_playlist)-1 if not up else True):

				to = draw_selected + (-1 if up else 1)
				mpd_move(draw_selected, to)

				tmp = mpd_playlist[draw_selected]
				mpd_playlist[draw_selected] = mpd_playlist[to]
				mpd_playlist[to] = tmp
				draw_selected = to
			else:
				status("can't move from there")

		elif ch == ord('/') or ch == ord('?') or ch == ord('n') or ch == ord('N'):
			go = True

			if ch == ord('/') or ch == ord('?'):
				search_rev = 0 if ch == ord('/') else 1
				go = getsearch(search_rev)

			lastmark()

			if go:
				order_adj = search_rev
				if ch == ord('N'):
					order_adj = 1 if order_adj == 0 else 0
				dosearch(order_adj)

		elif ch == ord('o'):
			lastmark()
			view_current()

		elif ch == ord('P'):
			password()

		elif ch == 410 or ch == 12:
			# 12 = "\f" = ctrl+L
			status('')

		elif ch == ord('h'):
			help()

		else: status("unknown key %d - 'h' for help" % ch)
	except MPDException as e:
		status("error: %s" % e)

	return True


# ----------------------------------------------------
# general code

def handle_idle():
	lines = mpd_readlines('idle')

	for l in lines:
		# database
		# update
		# stored_playlist
		# mixer
		# output
		# sticker
		# subscription
		# message

		if l.find('changed: ') == 0:
			l = l[9:]

			if l == 'options':
				# rzxyc opshuns
				mpd_getstate()
			elif l == 'playlist':
				mpd_updateplaylist()
				mpd_getplaying() # need to update the 'Pos' of playing
				clip_draw_selected()
			elif l == 'player':
				# play, pause, etc
				mpd_getstate()
				mpd_getplaying()


def input_wait():
	global sock

	mpd_idle(True)

	while True:
		try:
			ready = select.select([sock, sys.stdin], [], [])
			break
		except Exception as (errno, strerr):
			if errno != 4: # interrupted syscall
				raise

	# ready = ([sock?, sys.stdin?], [], [])

	if sock in ready[0]:
		handle_idle()
	else:
		mpd_idle(False)

	if sys.stdin in ready[0]:
		if not keys():
			return False

	return True


def run():
	global stdscr

	status("connected to mpd @ %s" % hoststr())

	while True:
		draw()
		stdscr.move(0, 0)
		stdscr.refresh()
		if not input_wait():
			break

	mpd_close()


if len(sys.argv) > 1:
	if len(sys.argv) == 2 and sys.argv[1] == '-T':
		TRACING = True
		print >>sys.stderr, "Tracing"
	else:
		cmd = "mpc "
		for arg in sys.argv[1:]:
			cmd += "%s " % arg
		sys.exit(os.system(cmd))


trace("init()")

try:
	stdscr = curses.initscr()

	curses.start_color()
	try:
		# ignore colour failures
		curses.use_default_colors()
		curses.init_pair(curses.COLOR_BLACK,   -1,                   -1)
		curses.init_pair(curses.COLOR_GREEN,   curses.COLOR_GREEN,   -1)
		curses.init_pair(curses.COLOR_WHITE,   curses.COLOR_WHITE,   -1)
		curses.init_pair(curses.COLOR_RED,     curses.COLOR_RED,     -1)
		curses.init_pair(curses.COLOR_CYAN,    curses.COLOR_CYAN,    -1)
		curses.init_pair(curses.COLOR_MAGENTA, curses.COLOR_MAGENTA, -1)
		curses.init_pair(curses.COLOR_BLUE,    curses.COLOR_BLUE,    -1)
		curses.init_pair(curses.COLOR_YELLOW,  curses.COLOR_YELLOW,  -1)
	except:
		pass

	curses.cbreak()
	curses.noecho()
	stdscr.keypad(1)
	stdscr.addstr(0, 0, 'connecting...')
except Exception as e:
	print "Couldn't start ncurses: %s" % e
	sys.exit(1)

printme = ''
lastexception = None
try:
	mpd_connect()
	mpd_playlist = mpd_getplaylist()

	mpd_getstate()
	mpd_getplaying()

	view_current()

	trace("calling run()")

	run()
except MPDException as e:
	printme = "MPDException: %s" % e
except KeyboardInterrupt as e:
	printme = "interrupted!"
except curses.error:
	printme = "mpcpy needs more columns on the terminal"
except Exception as e:
	lastexception = e

try:
	curses.nocbreak()
	curses.echo()
	curses.endwin()
except Exception:
	pass

if len(printme):
	print >>sys.stderr, printme
	sys.exit(1)
elif lastexception is not None:
	import traceback
	traceback.print_exc(lastexception)
